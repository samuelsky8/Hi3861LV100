/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2013-2015. All rights reserved.
 * Description: shell cmds APIs implementation
 * Author: none
 * Create: 2013
 */

#include "lwip/opt.h"
#include "netif/lowpan6_opts.h"
#include "lwip/api.h"
#include "lwip/tcpip.h"
#include "lwip/netif.h"
#include "lwip/netdb.h"
#include "lwip/stats.h"
#include "lwip/err.h"
#include "lwip/inet.h"
#include "netif/etharp.h"
#include "lwip/ip_addr.h"
#include "lwip/ip6_addr.h"
#include "lwip/icmp.h"
#if LWIP_IPV4 && LWIP_IGMP
#include "lwip/igmp.h"
#endif /* LWIP_IPV4 && LWIP_IGMP */
#include "lwip/priv/nd6_priv.h"
#include "lwip/sockets.h"
#include "lwip/inet_chksum.h"
#include "lwip/raw.h"
#include "lwip/priv/api_msg.h"
#include "los_config.h"
#include <string.h>
#include "limits.h"
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>

#include "lwip/api_shell.h"
#include "lwip/tftpc.h"

#include "lwip/dns.h"
#include "lwip/netdb.h"
#include "lwip/udp.h"
#include "lwip/priv/tcp_priv.h"
#if ((LWIP_IPV6 && (LWIP_IPV6_MLD || LWIP_IPV6_MLD_QUERIER)))
#include "lwip/mld6.h"
#endif /* ((LWIP_IPV6 && (LWIP_IPV6_MLD || LWIP_IPV6_MLD_QUERIER))) */

#include "lwip/dhcp.h"
#if LWIP_DHCPS
#include "lwip/dhcps.h"
#endif
#include "lwip/sntp.h"
#include "lwip/netifapi.h"

#ifdef LOSCFG_SHELL
#include "shcmd.h"
#include "shell.h"
#endif
#if LWIP_LITEOS_TASK
#include "hi_time.h"
#endif
#if LWIP_RIPPLE
#include "rpl_mgmt_api.h"
#include "of_helper.h"
#include "dag.h"
#include "pstore.h"
#include "rpl_common.h"
#endif

#if LWIP_RPL
#include "vpprpl-user-interfaces.h"
#include "vpprpl-cross-platform-interfaces.h"
#endif

#if LWIP_NAT64
#include "lwip/nat64.h"
#endif

#if LWIP_MPL
#include "mcast6_table.h"
#endif

#if LWIP_DHCP_COAP_RELAY
#include "dhcp_relay.h"
#endif

#ifdef CUSTOM_AT_COMMAND
#include "hi_at.h"
#endif

#define PRINT_BUF_LEN 1024
#define BYTE_CONVERT_UNIT 1024

typedef struct shell_cmd {
  int argc;
  char **argv;
  sys_sem_t cb_completed;
} shell_cmd_t;

struct ifconfig_option {
  char            iface[IFNAMSIZ];
  unsigned int    option;
  ip_addr_t       ip_addr;
  ip_addr_t       netmask;
  ip_addr_t       gw;
  unsigned char   ethaddr[NETIF_MAX_HWADDR_LEN];
  u16_t           mtu;
  /*
   * when using telnet, print to the telnet socket will result in system deadlock.
   * So we cahe the prinf data to a buf, and when the tcpip callback returns,
   * then print the data out to the telnet socket
   */
  sys_sem_t       cb_completed;
  char            cb_print_buf[PRINT_BUF_LEN];
  unsigned int    print_len;
};

struct netstat_data {
  s8_t *netstat_out_buf;
  u32_t netstat_out_buf_len;
  u32_t netstat_out_buf_updated_len;
  sys_sem_t cb_completed;
};

struct if_cmd_data {
  char *if_name;
  err_t err;
  sys_sem_t cb_completed;
};

#if LWIP_IPV6
/* Holds params for ping6 task */
typedef struct ping6_args {
  u8_t args_found;
  u8_t interface_index;
  u8_t host_index;
  u8_t pad;
  u32_t pingcount;
  ip6_addr_t src_addr;
  ip6_addr_t dst_addr;
} ping6_args_t;

/* Holds stats for ongoing ping6 task */
typedef struct ping6_stats {
  u32_t  flag;
  u32_t  min_rtt;
  u32_t  max_rtt;
  float  avg_rtt;
} ping6_stats_t;
#endif /* LWIP_IPV6 */

#if LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL
extern sys_sem_t ip_conflict_detect;
extern u32_t is_ip_conflict_signal;
LWIP_STATIC u32_t g_old_ip4addr;
#endif
#if LWIP_IPV6
extern sys_sem_t dup_addr_detect;
extern u32_t is_dup_detect_initialized;
#endif
extern int tcpip_init_finish;
extern struct etharp_entry arp_table[ARP_TABLE_SIZE];
extern u32_t sys_now(void);
extern const char *const tcp_state_str[];
#if (defined LWIP_TESTBED) || LWIP_ENABLE_BASIC_SHELL_CMD
extern int get_unused_socket_num(void);
#endif
/* Maximum tick value that can be generated by sys_now() */
#define LWIP_MAX_TICK                 0xFFFFFFFF
#define LWIP_TICK_SIZE                sizeof(u32_t)
#define LWIP_MAX_TICK_U64             0xFFFFFFFFFFFFFFFFLLU
#ifndef PRINT_ERR
#define PRINT_ERR PRINTK
#endif

#ifndef LWIP_IFCONFIG_SHOW_SINGLE
#define LWIP_IFCONFIG_SHOW_SINGLE 1
#endif

#define RESULT_STRING_LEN 320
#define LWIP_SHELL_CMD_PING6_RETRY_TIMES 4

#define MAX_PRINT_SIZE 256

#define IFCONFIG_OPTION_SET_IP          1
#define IFCONFIG_OPTION_SET_NETMASK     (1 << 1)
#define IFCONFIG_OPTION_SET_GW          (1 << 2)
#define IFCONFIG_OPTION_SET_HW          (1 << 3)
#define IFCONFIG_OPTION_SET_UP          (1 << 4)
#define IFCONFIG_OPTION_SET_DOWN        (1 << 5)
#define IFCONFIG_OPTION_SET_MTU         (1 << 6)
#define IFCONFIG_OPTION_DEL_IP          (1 << 7)

#define NETSTAT_ENTRY_SIZE 120
#define MAX_NETSTAT_ENTRY (NETSTAT_ENTRY_SIZE * (MEMP_NUM_TCP_PCB + MEMP_NUM_UDP_PCB  + MEMP_NUM_TCP_PCB_LISTEN + 1))

#define MAX_MACADDR_STRING_LENGTH    18 /* including NULL */

#define CONVERT_STRING_TO_HEX(_src, _dest) do { \
  const char *_srcString = (char *)(_src); \
  (_dest) = 0; \
  while (*_srcString != '\0') { \
    (_dest) = (unsigned char)(((_dest) << 4) & 0xFF); \
    if ((*_srcString >= '0') && (*_srcString <= '9')) { \
      (_dest) |= (unsigned char)(*_srcString - '0'); \
    } else if ((*_srcString >= 'A') && (*_srcString <= 'F')) { \
      (_dest) |= (unsigned char)((*_srcString - 'A') + 10); \
    } else if ((*_srcString >= 'a') && (*_srcString <= 'f')) { \
      (_dest) |= (unsigned char)((*_srcString - 'a') + 10); \
    } else { \
      break; \
    } \
    ++_srcString; \
  } \
} while (0)

#define ERR_IFCONFIG_STRING_PUT(ret, str) do { \
  (ret) = snprintf_s(ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len, \
                     PRINT_BUF_LEN - ifconfig_cmd->print_len, \
                     ((PRINT_BUF_LEN - ifconfig_cmd->print_len) - 1), "%s", (str)); \
  if (((ret) > 0) && ((unsigned int)(ret) < (PRINT_BUF_LEN - ifconfig_cmd->print_len))) { \
    ifconfig_cmd->print_len += (unsigned int)(ret); \
  } \
} while (0)

#define LWIP_MSECS_TO_SECS(time_in_msecs) ((time_in_msecs) / 1000)

#if LWIP_IPV6
#define LWIP_MAX_PING6_ARG_COUNT              64
#define LWIP_PING6_STANDARD_PKT_SIZE          56
#define LWIP_PING6_STARTING_SEQ_NUM           0x2255
#define LWIP_PING6_OUT_OF_ORDER_MAGNITUDE     1

#define LWIP_PING6_COUNT_ARG           1
#define LWIP_PING6_SOURCE_ADDRESS_ARG  2
#define LWIP_PING6_INTERFACE_ARG       4
#define LWIP_PING6_HOSTNAME_ARG        8
#define LWIP_PING6_DEFAULT_SOCKET      16
#endif

#if LWIP_ENABLE_BASIC_SHELL_CMD
#if LWIP_DNS
LWIP_STATIC unsigned int get_hostip(const char *hname);
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
struct hostent *gethostnameinfo(const char *host);
#endif /* LWIP_DNS */

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
int print_netif(struct netif *netif, char *print_buf, unsigned int buf_len);
/* Forward Declarations [START] */
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void lwip_ifconfig_show_internal(void *arg);
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void lwip_ifconfig_internal(void *arg);

void lwip_printsize(size_t size);
#ifndef CUSTOM_AT_COMMAND
LWIP_STATIC void lwip_ifconfig_usage(const char *cmd);
#endif

#if LWIP_IPV6
LWIP_STATIC void update_ping6_stats(ping6_stats_t *ping6_stats, u32_t rtt, u32_t nrecieved);
LWIP_STATIC int os_ping_fun6(u8_t type, void *param, ping6_args_t ping6_params);
LWIP_STATIC int parse_args_ping6(int argc, const char **argv, ping6_args_t *ping6_params);
u32_t osShellPing6(int argc, const char **argv);
LWIP_STATIC int create_ping6_socket(u8_t type, void *param);
LWIP_STATIC const char *convert_icmpv6_err_to_string(u8_t err_type);
#endif /* LWIP_IPV6 */
#endif /* LWIP_ENABLE_BASIC_SHELL_CMD */

#if LWIP_ENABLE_LOS_SHELL_CMD
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void lwip_arp_show_internal(struct netif *netif, char *printf_buf, unsigned int buf_len);

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void lwip_arp_internal(void *arg);
LWIP_STATIC void lwip_arp_usage(const char *cmd);
void ifup_internal(void *arg);
void ifdown_internal(void *arg);
#ifdef LWIP_DEBUG_INFO
LWIP_STATIC u32_t netdebug_memp(int argc, char **argv);
LWIP_STATIC u32_t netdebug_sock(int argc, char **argv);
u32_t osShellNetDebug(int argc, char **argv);
u32_t osShellIpDebug(int argc, char **argv);
#endif /* LWIP_DEBUG_INFO */
#if LWIP_IPV6
#if ICMP6_STATS
void lwip_print_icmpv6_stat(void);
#endif

#endif /* LWIP_IPV6 */
#endif /* LWIP_ENABLE_LOS_SHELL_CMD */

u32_t osTcpserver(int argc, char **argv);
void udpserver(int argc, char **argv);
#if LWIP_IPV6
int netstat_get_udp_sendQLen6(struct udp_pcb *udppcb, struct pbuf *udpbuf);
int netstat_udp_sendq6(struct udp_pcb *upcb);
#endif
#if LWIP_IPV4
int netstat_get_udp_sendQLen(struct udp_pcb *udppcb, struct pbuf *udpbuf);
#endif
int netstat_tcp_sendq(struct tcp_pcb *tpcb);
int netstat_tcp_recvq(struct tcp_pcb *tpcb);
int netstat_netconn_recvq(const struct netconn *conn);

int netstat_udp_sendq(struct udp_pcb *upcb);
int netstat_netconn_sendq(struct netconn *conn);
/* Forward Declarations [END] */

#if LWIP_ENABLE_BASIC_SHELL_CMD
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
int print_netif_ip(struct netif *netif, char *print_buf, unsigned int buf_len)
{
  int ret;
  char *tmp = print_buf;
  if (buf_len <= 1) {
    return -1;
  }
#if LWIP_IPV4
#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "ip=%s,", ipaddr_ntoa(&netif->ip_addr));
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "ip:%s ", ipaddr_ntoa(&netif->ip_addr));
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "netmask=%s,", ipaddr_ntoa(&netif->netmask));
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "netmask:%s ", ipaddr_ntoa(&netif->netmask));
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "gateway=%s,", ipaddr_ntoa(&netif->gw));
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "gateway:%s\n", ipaddr_ntoa(&netif->gw));
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;
#endif

#if LWIP_IPV6
  char *addr = NULL;
  int i;
  for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    /* only PREFERRED addresses are displyaed */
    if (!ip6_addr_isvalid(netif->ip6_addr_state[i])) {
      continue;
    }
    addr = ip6addr_ntoa((const ip6_addr_t *)&netif->ip6_addr[i]);
#ifdef CUSTOM_AT_COMMAND
    if (addr != NULL) {
      ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "ip6=%s,", addr);
      if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
        return -1;
      }
      tmp += ret;
      buf_len -= (unsigned int)ret;
    }
#else
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "\tip6: %s/64\n", addr ? addr : "::");
    if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
      return -1;
    }
    tmp += ret;
    buf_len -= (unsigned int)ret;
#endif
  }
#endif

  return (tmp - print_buf);
}

LWIP_STATIC int
print_netif_hw(struct netif *netif, char *print_buf, unsigned int buf_len)
{
  int ret, i;
  char *tmp = print_buf;
  if (buf_len <= 1) {
    return -1;
  }
#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s", "HWaddr=");
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s", "\tHWaddr ");
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  for (i = 0; i < netif->hwaddr_len - 1; i++) {
    ret = snprintf_s(tmp, buf_len, (buf_len - 1), "%02x:", netif->hwaddr[i]);
    if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
      return -1;
    }
    tmp += ret;
    buf_len -= (unsigned int)ret;
  }

#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%02x,", netif->hwaddr[i]);
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%02x", netif->hwaddr[i]);
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;

  return (tmp - print_buf);
}

LWIP_STATIC int
print_netif_link(struct netif *netif, char *print_buf, unsigned int buf_len)
{
  int ret;
  char *tmp = print_buf;
  if (buf_len <= 1) {
    return -1;
  }
#ifdef CUSTOM_AT_COMMAND
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "MTU=%d,", netif->mtu);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  /* 1:Link UP: netcard is connencted; 0:Link Down netcard is disconnect */
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "LinkStatus=%d,",
                   ((netif->flags & NETIF_FLAG_LINK_UP) != 0) ? 1 : 0);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), " MTU:%d %s", netif->mtu,
                   ((netif->flags & NETIF_FLAG_UP) != 0) ? "Running" : "Stop");
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  if (netif_default == netif && netif_is_up(netif)) {
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), " %s", "Default");
    if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
      return -1;
    }
    tmp += ret;
    buf_len -= (unsigned int)ret;
  }
#endif

#ifdef CUSTOM_AT_COMMAND
  /* 1:Running state; 0:Stop state */
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "RunStatus=%d\r\n",
                   ((netif->flags & NETIF_FLAG_UP) != 0) ? 1 : 0);
#else
  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), " %s\n",
                   ((netif->flags & NETIF_FLAG_LINK_UP) != 0) ? "Link UP" : "Link Down");
#endif
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;

  return (tmp - print_buf);
}

#if MIB2_STATS
LWIP_STATIC int
print_netif_mib(struct netif *netif, char *print_buf, unsigned int buf_len)
{
  int ret;
  char *tmp = print_buf;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "\tRX packets:%u ",
                   netif->mib2_counters.ifinucastpkts + netif->mib2_counters.ifinnucastpkts);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "errors:%u ", netif->mib2_counters.ifinerrors);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "dropped:%u ", netif->mib2_counters.ifindiscards);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "overruns:%u\n", netif->mib2_counters.ifinoverruns);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "\tTX packets:%u ",
                   netif->mib2_counters.ifoutucastpkts + netif->mib2_counters.ifoutnucastpkts);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "errors:%u ", netif->mib2_counters.ifouterrors);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "dropped:%u\n", netif->mib2_counters.ifoutdiscards);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "\tRX bytes:%u ", netif->mib2_counters.ifinoctets);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "TX bytes:%u\n", netif->mib2_counters.ifoutoctets);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return -1;
  }
  tmp += ret;
  return (tmp - print_buf);
}
#endif

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
int
print_netif(struct netif *netif, char *print_buf, unsigned int buf_len)
{
  int ret;
  char *tmp = print_buf;

#ifdef CUSTOM_AT_COMMAND
  /* printf +IFCFG */
  (void)hi_at_printf("+IFCFG:");
#endif

  if (netif->link_layer_type == LOOPBACK_IF) {
#ifdef CUSTOM_AT_COMMAND
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s,", netif->name);
#else
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s\t", netif->name);
#endif
  } else {
#ifdef CUSTOM_AT_COMMAND
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s%u,", netif->name, netif->num);
#else
    ret = snprintf_s(tmp, buf_len, (unsigned int)(buf_len - 1), "%s%u\t", netif->name, netif->num);
#endif
  }
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    goto out;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = print_netif_ip(netif, tmp, buf_len);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    goto out;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = print_netif_hw(netif, tmp, buf_len);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    goto out;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  ret = print_netif_link(netif, tmp, buf_len);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    goto out;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

#if MIB2_STATS
  ret = print_netif_mib(netif, tmp, buf_len);
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    goto out;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;
#endif

#if LWIP_IFCONFIG_SHOW_SINGLE
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("%s", print_buf);
#else
  PRINTK("%s", print_buf);
#endif
#endif
out:
  return (int)(tmp - print_buf);
}

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void
lwip_ifconfig_show_internal(void *arg)
{
  struct netif *netif = NULL;
  struct ifconfig_option *ifconfig_cmd = (struct ifconfig_option *)arg;
  int ret;

  if (netif_list == NULL) {
    ret = snprintf_s(ifconfig_cmd->cb_print_buf, PRINT_BUF_LEN - ifconfig_cmd->print_len,
                     ((PRINT_BUF_LEN - ifconfig_cmd->print_len) - 1), "%s", "Device not init\n");
    if ((ret > 0) && ((unsigned int)ret < (PRINT_BUF_LEN - ifconfig_cmd->print_len))) {
      ifconfig_cmd->print_len += (unsigned int)ret;
    }

    sys_sem_signal(&ifconfig_cmd->cb_completed);
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("ERROR\r\n");
#endif
    return;
  }

  if (ifconfig_cmd->iface[0] == '\0') {
    /* display all netif */
    for (netif = netif_list; netif != NULL; netif = netif->next) {
      ret = print_netif(netif,
                        ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
                        PRINT_BUF_LEN - ifconfig_cmd->print_len);
      ifconfig_cmd->print_len += (unsigned int)ret;
    }
  } else {
    netif = netif_find(ifconfig_cmd->iface);
    if (netif == NULL) {
      ret = snprintf_s(ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
                       (PRINT_BUF_LEN - ifconfig_cmd->print_len),
                       ((PRINT_BUF_LEN - ifconfig_cmd->print_len) - 1), "Device not found\n");
      if ((ret > 0) && ((unsigned int)ret < (PRINT_BUF_LEN - ifconfig_cmd->print_len))) {
        ifconfig_cmd->print_len += (unsigned int)ret;
      }

      sys_sem_signal(&ifconfig_cmd->cb_completed);
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("ERROR\r\n");
#endif
      return;
    }

    ret = print_netif(netif,
                      ifconfig_cmd->cb_print_buf + ifconfig_cmd->print_len,
                      PRINT_BUF_LEN - ifconfig_cmd->print_len);
    ifconfig_cmd->print_len += (unsigned int)ret;
  }
  sys_sem_signal(&ifconfig_cmd->cb_completed);

#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("OK\r\n");
#endif
}

LWIP_STATIC int
lwip_ifconfig_ip(struct netif *netif, struct ifconfig_option *ifconfig_cmd)
{
  ip_addr_t ip_addr;
  struct netif *loc_netif = NULL;
  int ret;
  s8_t idx;
  err_t err;

  ip_addr_set_val(&ip_addr, &(ifconfig_cmd->ip_addr));
  if (IP_IS_V4_VAL(ifconfig_cmd->ip_addr)) {
    /* check the address is not multicast/broadcast/0/loopback */
    if (ip_addr_ismulticast_val(&ip_addr) || ip_addr_isbroadcast_val(&ip_addr, netif) ||
        ip_addr_isany(&ip_addr) || ip_addr_isloopback(&ip_addr)) {
      ERR_IFCONFIG_STRING_PUT(ret, "Don't set ip as a multicast/broadcast/0/loopback address!\n");
      return -1;
    }

    /* reset gateway if new and previous ipaddr not in same net */
    if (!ip_addr_netcmp_val(&ip_addr, &netif->ip_addr, ip_2_ip4(&netif->netmask))) {
      ip_addr_set_zero(&netif->gw);
      if (netif == netif_default) {
        (void)netif_set_default(NULL);
      }
    }

    /* lwip disallow two netif sit in same net at the same time */
    loc_netif = netif_list;
    while (loc_netif != NULL) {
      if ((loc_netif == netif) || (ip4_addr_isany_val(loc_netif->netmask.u_addr.ip4))) {
        loc_netif = loc_netif->next;
        continue;
      }
      if (IP_IS_V4_VAL(ifconfig_cmd->ip_addr) && ip_addr_cmp(&netif->netmask, &loc_netif->netmask) &&
          ip_addr_netcmp_val(&loc_netif->ip_addr, &ip_addr, ip_2_ip4(&netif->netmask))) {
        ERR_IFCONFIG_STRING_PUT(ret, "Duplicate network!\n");
        return -1;
      }
      loc_netif = loc_netif->next;
    }

#if LWIP_DHCP
    if ((netif_dhcp_data(netif) != NULL) &&
        (netif_dhcp_data(netif)->client.states[LWIP_DHCP_NATIVE_IDX].state != DHCP_STATE_OFF)) {
      (void)netif_dhcp_off(netif);
    }
#endif
    netif_set_ipaddr(netif, ip_2_ip4(&ip_addr));
  } else if (IP_IS_V6_VAL(ifconfig_cmd->ip_addr)) {
    idx = -1;
    err = netif_add_ip6_address(netif, ip_2_ip6(&ip_addr), &idx);
    if ((err != ERR_OK) || (idx == -1)) {
      ERR_IFCONFIG_STRING_PUT(ret,
                              "The IPv6 has reached the Global addr limit,you need delete one address before add!\n");
      return -1;
    }
  }

  return 0;
}

LWIP_STATIC int
lwip_ifconfig_netmask(struct netif *netif, struct ifconfig_option *ifconfig_cmd)
{
  ip_addr_t netmask;
  struct netif *loc_netif = NULL;
  int ret;

  ip_addr_set_val(&netmask, &(ifconfig_cmd->netmask));
  /* check data valid */
  if (ip_addr_netmask_valid(ip_2_ip4(&netmask)) == 0) {
    ERR_IFCONFIG_STRING_PUT(ret, "ifconfig: netmask is invalid!\n");
    return -1;
  }

#if LWIP_DHCP
  if ((netif_dhcp_data(netif) != NULL) &&
      (netif_dhcp_data(netif)->client.states[LWIP_DHCP_NATIVE_IDX].state != DHCP_STATE_OFF)) {
    (void)netif_dhcp_off(netif);
  }
#endif
  if (netif_ip4_netmask(netif)->addr != ip_2_ip4(&netmask)->addr) {
    /* lwip disallow two netif sit in same net at the same time */
    loc_netif = netif_list;
    while (loc_netif != NULL) {
      if (loc_netif == netif) {
        loc_netif = loc_netif->next;
        continue;
      }
      if (ip_addr_cmp(&loc_netif->netmask, &netmask) &&
          ip_addr_netcmp(&loc_netif->ip_addr,
                         &netif->ip_addr, ip_2_ip4(&netmask))) {
        ERR_IFCONFIG_STRING_PUT(ret, "Duplicate network!\n");
        return -1;
      }
      loc_netif = loc_netif->next;
    }
    netif_set_netmask(netif, ip_2_ip4(&netmask));
    /* check if gateway still reachable */
    if (!ip_addr_netcmp(&netif->gw,
                        &netif->ip_addr, ip_2_ip4(&netmask))) {
      ip_addr_set_zero(&(netif->gw));
      if (netif == netif_default) {
        (void)netif_set_default(NULL);
      }
    }
  }
  return 0;
}

LWIP_STATIC int
lwip_ifconfig_gw(struct netif *netif, struct ifconfig_option *ifconfig_cmd)
{
  ip_addr_t gw;
  int ret;

  ip_addr_set_val(&gw, &ifconfig_cmd->gw);

  /* check the address multicast/0/loopback */
  if (ip_addr_ismulticast_val(&gw) || ip_addr_isbroadcast_val(&gw, netif) ||
      ip_addr_isany(&gw) || ip_addr_isloopback(&gw)) {
    ERR_IFCONFIG_STRING_PUT(ret, "Don't set gateway as a multicast/broadcast/0/loopback address!\n");
    return -1;
  }

  /* check if reachable */
  if (!ip_addr_netcmp_val(&gw, &netif->ip_addr, ip_2_ip4(&netif->netmask))) {
    ERR_IFCONFIG_STRING_PUT(ret, "The address is unreachable!\n");
    return -1;
  }

  if (netif_default != netif) {
    ip_addr_set_zero(&netif->gw);
    (void)netif_set_default(netif);
  }

#if LWIP_DHCP
  if ((netif_dhcp_data(netif) != NULL) &&
      (netif_dhcp_data(netif)->client.states[LWIP_DHCP_NATIVE_IDX].state != DHCP_STATE_OFF)) {
    (void)netif_dhcp_off(netif);
  }
#endif
  netif_set_gw(netif, ip_2_ip4(&gw));
  return 0;
}

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void
lwip_ifconfig_internal(void *arg)
{
  struct ifconfig_option *ifconfig_cmd = NULL;
  struct netif *netif = NULL;
  int ret;

  ifconfig_cmd = (struct ifconfig_option *)arg;
  netif = netif_find(ifconfig_cmd->iface);
  if (netif == NULL) {
    ERR_IFCONFIG_STRING_PUT(ret, "Device not found\n");
    goto out;
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_UP) != 0) {
    (void)netif_set_link_up(netif);
    (void)netif_set_up(netif);
    goto out;
  } else if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_DOWN) != 0) {
    (void)netif_set_down(netif);
    (void)netif_set_link_down(netif);
    goto out;
  }

  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) ||
      ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_NETMASK) != 0) ||
      ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_HW) != 0)) {
    (void)netif_set_down(netif);
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) {
    if (lwip_ifconfig_ip(netif, ifconfig_cmd) != 0) {
      goto out;
    }
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_DEL_IP) != 0) {
    (void)netif_do_rmv_ipv6_addr(netif, &ifconfig_cmd->ip_addr);
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_NETMASK) != 0) {
    if (lwip_ifconfig_netmask(netif, ifconfig_cmd) != 0) {
      goto out;
    }
  }

  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_HW) != 0) &&
      (netif_set_hwaddr(netif, ifconfig_cmd->ethaddr, NETIF_MAX_HWADDR_LEN) != ERR_OK)) {
    ERR_IFCONFIG_STRING_PUT(ret, "Failed to update the hwaddr of the device!\n");
    (void)netif_set_up(netif);
    goto out;
  }

  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) ||
      ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_NETMASK) != 0) ||
      ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_HW) != 0)) {
    (void)netif_set_up(netif);
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_GW) != 0) {
    if (lwip_ifconfig_gw(netif, ifconfig_cmd) != 0) {
      goto out;
    }
  }

  if ((ifconfig_cmd->option & IFCONFIG_OPTION_SET_MTU) != 0) {
    if (netif_set_mtu(netif, ifconfig_cmd->mtu) != ERR_OK) {
      ERR_IFCONFIG_STRING_PUT(ret, "Invalid arguments:mtu should be in [68, 1500]\n");
    }
  }
out:
  sys_sem_signal(&ifconfig_cmd->cb_completed);
}

void
lwip_printsize(size_t size)
{
  static const char *sizes[] = { "B", "KB", "MB", "GB" };
  size_t divis = 0;
  size_t rem = 0;
  while ((size >= BYTE_CONVERT_UNIT) && (divis < ((sizeof(sizes) / sizeof(char *)) - 1))) {
    rem = (size % BYTE_CONVERT_UNIT);
    divis++;
    size /= BYTE_CONVERT_UNIT;
  }
  /* 1024.0 : byte in float unit */
  PRINTK("(%.1f %s) \r\n", (float)size + (float)rem / 1024.0, sizes[divis]);
}

#ifndef CUSTOM_AT_COMMAND
LWIP_STATIC void
lwip_ifconfig_usage(const char *cmd)
{
  PRINTK("Usage:"\
         "\n%s [-a] "\
         "\n[interface]"\
         "\n[interface ipaddr] <netmask mask> <gateway gw>"\
         "\n[interface inet6 add|del ipaddr]"\
         "\n[interface hw ether MAC]"\
         "\n[interface mtu NN]"\
         "\n[interface up|down]\n",
         cmd);
}
#endif

u32_t lwip_get_ipv4(char *localIp, unsigned char ipLen, unsigned char *ifname)
{
  struct netif* netif = NULL;
  int ret;

  if (ifname == NULL) {
    PRINTK("ifname null ptr.\n");
    return LOS_NOK;
  }

  netif = netif_find((const char *)ifname);
  if (netif == NULL) {
    PRINTK("Device not found.\n");
    return LOS_NOK;
  }

  ret = snprintf_s(localIp, (size_t)ipLen, (size_t)(ipLen - 1), "%s", ipaddr_ntoa(&netif->ip_addr));
  if ((ret <= 0) || ((unsigned int)ret >= ipLen)) {
    return LOS_NOK;
  }
  return LOS_OK;
}

u32_t lwip_get_mac_addr(unsigned char *macAddr, unsigned int len, unsigned char *ifname)
{
  struct netif* netif = NULL;
  int i;
  int ret;

  if (ifname == NULL) {
    PRINTK("ifname null ptr.\n");
    return LOS_NOK;
  }

  netif = netif_find((const char *)ifname);
  if (netif == NULL) {
    PRINTK("Device not found.\n");
    return LOS_NOK;
  }

  for (i = 0; i < netif->hwaddr_len - 1; i++) {
    ret = snprintf_s((char *)macAddr, len, (len - 1), "%02x:", netif->hwaddr[i]);
    if ((ret <= 0) || ((unsigned int)ret >= len)) {
      return LOS_NOK;
    }
    macAddr += ret;
    len -= (unsigned int)ret;
  }

  ret = snprintf_s((char *)macAddr, len, (len - 1), "%02x", netif->hwaddr[i]);
  if ((ret <= 0) || ((unsigned int)ret >= len)) {
    return LOS_NOK;
  }
  return LOS_OK;
}

#ifndef CUSTOM_AT_COMMAND
LWIP_STATIC u32_t lwip_ifconfig_all(int argc, const char **argv)
{
  /* To support "ifconfig -a" command
   *   RX packets:XXXX errors:X dropped:X overruns:X bytes:XXXX (Human readable format)
   *   TX packets:XXXX errors:X dropped:X overruns:X bytes:XXXX (Human readable format)
   *
   *   Below is assumed for 'overrun' stat.
   *   Linux Kernel:
   *          RX: FIFO overrun
   *              Data structure: net_device->stats->rx_fifo_errors
   *              Flag which is marked when FIFO overrun: ENRSR_FO
   *
   *          Function: ei_receive->ENRSR_FO
   *
   *          TX: A "FIFO underrun" occurred during transmit.
   *              Data structure: net_device->stats->tx_fifo_errors
   *              Flag which is marked when FIFO underrun: ENTSR_FU
   *
   *          Function: ei_tx_intr->ENTSR_FU
   *
   *  LWIP:
   *      So in our case,
   *      while receiving a packet RX case, if the buffer is full (trypost - it is sys_mbox_trypost)
   *      the error will be returned, we can consider that an overflow has happend.
   *      So this can be RX overrun.
   *
   *      But while transmitting a packet TX case, underrun cannot happen because it block on the
   *      message Q if it is full (NOT trypost - it is sys_mbox_post). So TX overrun is always 0.
   */
#if LWIP_STATS
  u32_t stat_err_cnt;
  u32_t stat_drop_cnt;
  u32_t stat_rx_or_tx_cnt;
  u32_t stat_rx_or_tx_bytes;

  stat_rx_or_tx_cnt     = lwip_stats.ip.recv;
  stat_err_cnt          = (u32_t)(lwip_stats.ip.ip_rx_err
                                  + lwip_stats.ip.lenerr
                                  + lwip_stats.ip.chkerr
                                  + lwip_stats.ip.opterr
                                  + lwip_stats.ip.proterr);
  stat_drop_cnt         = (u32_t)(lwip_stats.ip.drop + lwip_stats.link.link_rx_drop);
  stat_rx_or_tx_bytes = lwip_stats.ip.ip_rx_bytes;

  PRINTK("%18s:%u\t errors:%u\t ip dropped:%u\t link dropped:%u\t overrun:%d\t bytes:%u ",
         "RX packets",
         stat_rx_or_tx_cnt,
         stat_err_cnt,
         stat_drop_cnt,
         lwip_stats.link.link_rx_drop,
         lwip_stats.ip.link_rx_overrun,
         stat_rx_or_tx_bytes);

  /* Print in Human readable format of the incoming bytes */
  lwip_printsize(lwip_stats.ip.ip_rx_bytes);
#if IP6_STATS
  stat_rx_or_tx_cnt     = lwip_stats.ip6.recv;
  stat_err_cnt          = (u32_t)(lwip_stats.ip6.ip_rx_err
                                  + lwip_stats.ip6.lenerr
                                  + lwip_stats.ip6.chkerr
                                  + lwip_stats.ip6.opterr
                                  + lwip_stats.ip6.proterr);
  stat_drop_cnt         = lwip_stats.ip6.drop;
  stat_rx_or_tx_bytes = lwip_stats.ip6.ip_rx_bytes;

  PRINTK("%18s:%u\t errors:%u\t dropped:%u\t overrun:%d\t bytes:%u ",
         "RX packets(ip6)",
         stat_rx_or_tx_cnt,
         stat_err_cnt,
         stat_drop_cnt,
         lwip_stats.ip.link_rx_overrun,
         stat_rx_or_tx_bytes);

  /* Print in Human readable format of the incoming bytes */
  lwip_printsize(lwip_stats.ip6.ip_rx_bytes);
#endif
  stat_rx_or_tx_cnt     = (u32_t)(lwip_stats.ip.fw + lwip_stats.ip.xmit);
  stat_err_cnt          = (u32_t)(lwip_stats.ip.rterr + lwip_stats.ip.ip_tx_err);
  /* IP layer drop stat param is not maintained, failure at IP is considered in 'errors' stat */
  stat_drop_cnt         = lwip_stats.link.link_tx_drop;
  stat_rx_or_tx_bytes   = lwip_stats.ip.ip_tx_bytes;

  PRINTK("%18s:%u\t errors:%u\t link dropped:%u\t overrun:0\t bytes:%u",
         "TX packets",
         stat_rx_or_tx_cnt,
         stat_err_cnt,
         stat_drop_cnt,
         stat_rx_or_tx_bytes);

  /* Print in Human readable format of the outgoing bytes */
  lwip_printsize(lwip_stats.ip.ip_tx_bytes);

  stat_rx_or_tx_cnt     = (u32_t)(lwip_stats.ip6.fw + lwip_stats.ip6.xmit);
  stat_err_cnt          = (u32_t)(lwip_stats.ip6.rterr + lwip_stats.ip6.ip_tx_err);
  stat_rx_or_tx_bytes   = lwip_stats.ip6.ip_tx_bytes;

  PRINTK("%18s:%u\t errors:%u\t overrun:0\t bytes:%u",
         "TX packets(ip6)",
         stat_rx_or_tx_cnt,
         stat_err_cnt,
         stat_rx_or_tx_bytes);

  /* Print in Human readable format of the outgoing bytes */
  lwip_printsize(lwip_stats.ip6.ip_tx_bytes);
#endif /* LWIP_STATS */
  return 0;
}
#endif

LWIP_STATIC u32_t lwip_ifconfig_callback(tcpip_callback_fn function, struct ifconfig_option *ifconfig_cmd)
{
  err_t ret;
  if ((ret = tcpip_callback(function, ifconfig_cmd)) != ERR_OK) {
    sys_sem_free(&ifconfig_cmd->cb_completed);
    PRINTK("ifconfig : internal error, l:%d err:%d\n", __LINE__, ret);
    return LOS_NOK;
  }
  (void)sys_arch_sem_wait(&ifconfig_cmd->cb_completed, 0);
  sys_sem_free(&ifconfig_cmd->cb_completed);

  ifconfig_cmd->cb_print_buf[PRINT_BUF_LEN - 1] = '\0';
  return LOS_OK;
}

LWIP_STATIC u32_t lwip_ifconfig_print_all(struct ifconfig_option *ifconfig_cmd)
{
  u32_t ret = lwip_ifconfig_callback(lwip_ifconfig_show_internal, ifconfig_cmd);
  if (ret != 0) {
    return ret;
  }

#if (LWIP_IFCONFIG_SHOW_SINGLE != lwIP_TRUE)
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("+IFCONFIG:");
  (void)hi_at_printf("%s", ifconfig_cmd->cb_print_buf);
  (void)hi_at_printf("OK\r\n");
#else
  PRINTK("%s", ifconfig_cmd->cb_print_buf);
#endif
#endif
  return LOS_OK;
}

LWIP_STATIC u32_t lwip_ifconfig_up_down(struct ifconfig_option *ifconfig_cmd)
{
  u32_t ret = lwip_ifconfig_callback(lwip_ifconfig_internal, ifconfig_cmd);
  if (ret != 0) {
    return ret;
  }

#ifndef CUSTOM_AT_COMMAND
  PRINTK("%s", ifconfig_cmd->cb_print_buf);
  return 0;
#else
  return LOS_NOK;
#endif
}

LWIP_STATIC u32_t
lwip_ifconfig_prase_inet(int *argc, const char **argv, int *idx,
                         struct ifconfig_option *ifconfig_cmd)
{
#if LWIP_ARP
  struct netif *netiftmp = NULL;
#endif /* LWIP_ARP */

  /* check if set the ip address. */
#if LWIP_ARP
  netiftmp = netif_find(ifconfig_cmd->iface);
  if (NULL == netiftmp) {
    PRINTK("ifconfig : Interface %s not found\n", ifconfig_cmd->iface);
    return EINVAL;
  }
  g_old_ip4addr = ipaddr_addr(ipaddr_ntoa(&netiftmp->ip_addr));
#endif /* LWIP_ARP */
  if ((strcmp(argv[*idx], "inet") == 0) || (ip4addr_aton(argv[*idx], ip_2_ip4(&ifconfig_cmd->ip_addr)) != 0)) {
    if (strcmp(argv[*idx], "inet") == 0) {
      if (*argc <= 1) {
        return EINVAL;
      }

      if (ip4addr_aton(argv[*idx + 1], ip_2_ip4(&ifconfig_cmd->ip_addr)) == 0) {
        PRINTK("ifconfig : Invalid IPv4 Address\n");
        return EINVAL;
      }
      (*argc)--;
      (*idx)++;
    }
    IP_SET_TYPE_VAL((ifconfig_cmd->ip_addr), IPADDR_TYPE_V4);
#if LWIP_ARP
    if (!ip_addr_cmp(&ifconfig_cmd->ip_addr, &netiftmp->ip_addr)) {
      ifconfig_cmd->option |= IFCONFIG_OPTION_SET_IP;
    }
#else
    ifconfig_cmd->option |= IFCONFIG_OPTION_SET_IP;
#endif /* LWIP_ARP */
    (*argc)--;
    (*idx)++;
  } else if (strcmp(argv[*idx], "inet6") == 0) {
    /* 3 : min argc parameter num from command line */
    if (*argc < 3) {
      return LOS_NOK;
    }
    if ((strcmp(argv[*idx + 1], "add") != 0) && (strcmp(argv[*idx + 1], "del") != 0)) {
      return LOS_NOK;
    }
    /* 2 : skip two argv index */
    if (ip6addr_aton(argv[*idx + 2], ip_2_ip6(&ifconfig_cmd->ip_addr)) == 0) {
      PRINTK("ifconfig : Invalid IPv6 Address\n");
      return EINVAL;
    }

    IP_SET_TYPE_VAL((ifconfig_cmd->ip_addr), IPADDR_TYPE_V6);
    ifconfig_cmd->option |= (!strcmp(argv[*idx + 1], "add") ? IFCONFIG_OPTION_SET_IP : IFCONFIG_OPTION_DEL_IP);
    *argc -= 3; /* 3: skip already check three parameter */
    (*idx) += 3; /* 3: skip three argv index */
  }

  if (((ifconfig_cmd->option & IFCONFIG_OPTION_DEL_IP) != 0) && (*argc != 0)) {
    return LOS_NOK;
  }

  return LOS_OK;
}

LWIP_STATIC u32_t
lwip_ifconfig_prase_additional(int *argc, const char **argv, int *idx,
                               struct ifconfig_option *ifconfig_cmd)
{
  while (*argc > 0) {
    /* if set netmask */
    if ((strcmp("netmask", argv[*idx]) == 0) && (*argc > 1) &&
        (ipaddr_addr(argv[*idx + 1]) != IPADDR_NONE)) {
      ip_addr_set_ip4_u32_val(&(ifconfig_cmd->netmask), ipaddr_addr(argv[*idx + 1]));
      ifconfig_cmd->option |= IFCONFIG_OPTION_SET_NETMASK;
      *idx += 2; /* 2: skip two argv index */
      *argc -= 2; /* 2: skip already check two parameter */
    } else if ((strcmp("gateway", argv[*idx]) == 0) && (*argc > 1) && /* if set gateway */
               (ipaddr_addr(argv[*idx + 1]) != IPADDR_NONE)) {
      ip_addr_set_ip4_u32_val(&(ifconfig_cmd->gw), ipaddr_addr(argv[*idx + 1]));
      ifconfig_cmd->option |= IFCONFIG_OPTION_SET_GW;
      *idx += 2; /* 2: skip two argv index */
      *argc -= 2; /* 2: skip already check two parameter */
    } else if ((strcmp("hw", argv[*idx]) == 0) && (*argc > 2) && /* 2 : if set HWaddr and more than two parameter */
               (strcmp("ether", argv[*idx + 1]) == 0)) {
      char *digit = NULL;
      u32_t macaddrlen = strlen(argv[*idx + 2]) + 1; /* 2: skip two argv index */
      char tmp_str[MAX_MACADDR_STRING_LENGTH];
      char *tmp_str1 = NULL;
      char *saveptr = NULL;
      int j;

      if (macaddrlen != MAX_MACADDR_STRING_LENGTH) {
        PRINTK("ifconfig : wrong MAC address format\n");
        return EINVAL;
      }
      /* 2: skip two argv index */
      if (strncpy_s(tmp_str, MAX_MACADDR_STRING_LENGTH, argv[*idx + 2], macaddrlen - 1) != EOK) {
        PRINTK("ifconfig : wrong MAC address\n");
        return EINVAL;
      }
      /* 6 : max ':' num */
      for (j = 0, tmp_str1 = tmp_str; j < 6; j++, tmp_str1 = NULL) {
        digit = strtok_r(tmp_str1, ":", &saveptr);
        if ((digit == NULL) || (strlen(digit) > 2)) { /* 2 : char len */
          PRINTK("ifconfig : wrong MAC address format\n");
          return EINVAL;
        }
        CONVERT_STRING_TO_HEX(digit, ifconfig_cmd->ethaddr[j]);
      }
      ifconfig_cmd->option |= IFCONFIG_OPTION_SET_HW;
      *idx += 3; /* 3: skip already check three parameter */
      *argc -= 3; /* 3: skip three argv index */
    } else if ((strcmp("mtu", argv[*idx]) == 0) && (*argc > 1)) { /* if set mtu */
      if ((atoi(argv[*idx + 1]) < 0) || (atoi(argv[*idx + 1]) > 0xFFFF)) { /* 0xFFFF : max argv num */
        PRINTK("\nifconfig: Invalid argument for mtu\n");
        return EINVAL;
      }

      ifconfig_cmd->mtu = (u16_t)(atoi(argv[*idx + 1]));
      ifconfig_cmd->option |= IFCONFIG_OPTION_SET_MTU;
      *idx += 2; /* 2: skip two argv index */
      *argc -= 2; /* 2: skip already check two parameter */
    } else {
      return LOS_NOK;
    }
  }

  return LOS_OK;
}

LWIP_STATIC u32_t
lwip_ifconfig_prase_args(int *argc, const char **argv, int *idx,
                         struct ifconfig_option *ifconfig_cmd)
{
  u32_t ret = lwip_ifconfig_prase_inet(argc, argv, idx, ifconfig_cmd);
  if (ret != 0) {
    return ret;
  }

  ret = lwip_ifconfig_prase_additional(argc, argv, idx, ifconfig_cmd);
  if (ret != 0) {
    return ret;
  }

#if LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL
  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V4_VAL((ifconfig_cmd->ip_addr))) {
    /* Create the semaphore for ip conflict detection. */
    if (sys_sem_new(&ip_conflict_detect, 0) != ERR_OK) {
      PRINTK("ifconfig: internal error\n");
      return EINVAL;
    }
    is_ip_conflict_signal = 1;
  }
#endif /* LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL */

#if LWIP_IPV6
  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V6_VAL((ifconfig_cmd->ip_addr))) {
    /* Create the semaphore for duplicate address detection. */
    if (sys_sem_new(&dup_addr_detect, 0) != ERR_OK) {
      PRINTK("ifconfig: internal error\n");
      return EINVAL;
    }
    is_dup_detect_initialized = 1;
  }
#endif /* LWIP_IPV6 */
  return LOS_OK;
}

LWIP_STATIC void
lwip_ifconfig_conflict_res_free(struct ifconfig_option *ifconfig_cmd)
{
#if LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL
    if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V4_VAL((ifconfig_cmd->ip_addr))) {
      is_ip_conflict_signal = 0;
      sys_sem_free(&ip_conflict_detect);
    }
#endif /* LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL */

#if LWIP_IPV6
    if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V6_VAL((ifconfig_cmd->ip_addr))) {
      is_dup_detect_initialized = 0;
      sys_sem_free(&dup_addr_detect);
    }
#endif /* LWIP_IPV6 */
}

LWIP_STATIC u32_t
lwip_ifconfig_conflict_process(struct ifconfig_option *ifconfig_cmd)
{
#if LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL
  err_t err;
  /* Pend 2 seconds for waiting the arp reply if the ip is already in use. */
  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V4_VAL((ifconfig_cmd->ip_addr))) {
    err = (err_t)sys_arch_sem_wait(&ip_conflict_detect, DUP_ARP_DETECT_TIME);
    is_ip_conflict_signal = 0;
    sys_sem_free(&ip_conflict_detect);
    if (err < 0) {
      /* The result neither conflict nor timeout. */
      PRINT_ERR("ifconfig: internal error\n");
      return LOS_NOK;
    } else if (err < DUP_ARP_DETECT_TIME) {
      /* Duplicate use of new ip, restore it to the old one. */
      PRINT_ERR("ifconfig: ip conflict!\n");
      ip_addr_set_ip4_u32_val(&ifconfig_cmd->ip_addr, g_old_ip4addr);
      if (sys_sem_new(&ifconfig_cmd->cb_completed, 0) != ERR_OK) {
        PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
       return LOS_NOK;
      }
      if ((err = tcpip_callback(lwip_ifconfig_internal, ifconfig_cmd)) != ERR_OK) {
        PRINTK("%s : tcpip_callback failed in line %d : errnu %d", __FUNCTION__, __LINE__, err);
        return LOS_NOK;
      }
      (void)sys_arch_sem_wait(&ifconfig_cmd->cb_completed, 0);
      ifconfig_cmd->cb_print_buf[PRINT_BUF_LEN - 1] = '\0';
#ifndef CUSTOM_AT_COMMAND
      PRINTK("%s", ifconfig_cmd->cb_print_buf);
#endif
      return LOS_NOK;
    }
  }
#endif /* LWIP_ARP && LWIP_ENABLE_IP_CONFLICT_SIGNAL */
#if LWIP_IPV6
  if (((ifconfig_cmd->option & IFCONFIG_OPTION_SET_IP) != 0) && IP_IS_V6_VAL(ifconfig_cmd->ip_addr)) {
    /* Pend 2 seconds for waiting the arp reply if the ip is already in use. */
    u32_t retval = sys_arch_sem_wait(&dup_addr_detect, DUP_ARP_DETECT_TIME);
    is_dup_detect_initialized = 0;
    sys_sem_free(&dup_addr_detect);

    if (retval == SYS_ARCH_ERROR) {
      /* The result neither conflict nor timeout. */
      PRINT_ERR("ifconfig: internal error\n");
      return LOS_NOK;
    } else if (retval < DUP_ARP_DETECT_TIME) {
      /* Duplicate use of new ip, restore it to the old one. */
      struct netif *netif = NULL;
      PRINT_ERR("ifconfig: IP conflict!\n");
      netif = netif_find(ifconfig_cmd->iface);
      s8_t i = netif_get_ip6_addr_match(netif, &ifconfig_cmd->ip_addr.u_addr.ip6);
      if (i >= 0) {
        netif->ip6_addr_state[i] = IP6_ADDR_INVALID;
      }

      ifconfig_cmd->cb_print_buf[PRINT_BUF_LEN - 1] = '\0';
#ifndef CUSTOM_AT_COMMAND
      PRINTK("%s", ifconfig_cmd->cb_print_buf);
#endif
      return LOS_NOK;
    }
  }
#endif /* LWIP_IPV6 */

  return LOS_OK;
}

LWIP_STATIC u32_t
lwip_ifconfig_basic(int *argc, const char **argv, int *idx,
                    struct ifconfig_option *ifconfig_cmd)
{
  /* Get the interface */
  if (*argc > 0) {
    if (strlen(argv[*idx]) < IFNAMSIZ) {
      (void)strncpy_s(ifconfig_cmd->iface, IFNAMSIZ, argv[*idx], (strlen(argv[*idx])));
      ifconfig_cmd->iface[IFNAMSIZ - 1] = '\0';
    } else {
      sys_sem_free(&ifconfig_cmd->cb_completed);
      PRINTK("ifconfig : interface name is too big\n");
      return 1;
    }
    (*idx)++;
    (*argc)--;
  }

  if (*argc == 0) {
    return lwip_ifconfig_print_all(ifconfig_cmd);
  }

  /* ifup/ifdown */
  if (strcmp("up", argv[*idx]) == 0) {
    ifconfig_cmd->option |= IFCONFIG_OPTION_SET_UP;
  } else if (strcmp("down", argv[*idx]) == 0) {
    ifconfig_cmd->option |= IFCONFIG_OPTION_SET_DOWN;
  }

  if ((ifconfig_cmd->option & (IFCONFIG_OPTION_SET_UP | IFCONFIG_OPTION_SET_DOWN)) != 0) {
    return lwip_ifconfig_up_down(ifconfig_cmd);
  }

  /* not a basic process, continue next process */
  return (u32_t)(-1);
}

u32_t
lwip_ifconfig(int argc, const char **argv)
{
  int i;
  static struct ifconfig_option ifconfig_cmd;
  u32_t ret;
  if (argv == NULL) {
    return LOS_NOK;
  }

  if (!tcpip_init_finish) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

#ifndef CUSTOM_AT_COMMAND
  if (argc != 0 && strcmp("-a", argv[0]) == 0) {
    return lwip_ifconfig_all(argc, argv);
  }
#endif

  (void)memset_s(&ifconfig_cmd, sizeof(ifconfig_cmd), 0, sizeof(ifconfig_cmd));
  if (sys_sem_new(&ifconfig_cmd.cb_completed, 0) != ERR_OK) {
    PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
    return LOS_NOK;
  }

  i = 0;
  ret = lwip_ifconfig_basic(&argc, argv, &i, &ifconfig_cmd);
  if (ret != (u32_t)(-1)) {
    return ret;
  }

  ret = lwip_ifconfig_prase_args(&argc, argv, &i, &ifconfig_cmd);
  if (ret != 0) {
    if (ret == EINVAL) {
      goto ifconfig_error;
    }

    goto ifconfig_usage_error;
  }

  ret = lwip_ifconfig_callback(lwip_ifconfig_internal, &ifconfig_cmd);
  if (ret != 0) {
    lwip_ifconfig_conflict_res_free(&ifconfig_cmd);
    PRINTK("%s : tcpip_callback failed in line %d : errnu %u", __FUNCTION__, __LINE__, ret);
    return ret;
  }
#ifndef CUSTOM_AT_COMMAND
  PRINTK("%s", ifconfig_cmd.cb_print_buf);
#endif

  ret = lwip_ifconfig_conflict_process(&ifconfig_cmd);
  if (ret != 0) {
    return LOS_NOK;
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("OK\r\n");
#endif
  return LOS_OK;

ifconfig_usage_error:
#ifndef CUSTOM_AT_COMMAND
  lwip_ifconfig_usage("ifconfig");
#endif
ifconfig_error:
  sys_sem_free(&ifconfig_cmd.cb_completed);
  return LOS_NOK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ifconfig_shellcmd, CMD_TYPE_EX, "ifconfig", XARGS, (CmdCallBackFunc)lwip_ifconfig);
#endif /* LOSCFG_SHELL */

#if LWIP_DNS
#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
struct hostent *
gethostnameinfo(const char *host)
{
  static struct hostent hostbuf;
  struct hostent *hp = NULL;
  size_t hstbuflen;
  char tmphstbuf[1024] = {0}; /* 1024 : host buffer */
  int res;
  int herr;

  hstbuflen = LWIP_ARRAYSIZE(tmphstbuf) - 1;

  res = lwip_gethostbyname_r(host, &hostbuf, tmphstbuf, hstbuflen,
                             &hp, &herr);
  /*  Check for errors.  */
  if ((res != 0) || (hp == NULL)) {
    return NULL;
  }
  return hp;
}

LWIP_STATIC unsigned int
get_hostip(const char *hname)
{
  unsigned int ip = 0;

  struct hostent *pent = gethostnameinfo(hname);
  if ((pent == NULL) || (pent->h_addr == NULL)) {
    return 0;
  }
  (void)memcpy_s(&ip, sizeof(ip), pent->h_addr, sizeof(ip));
  return ip;
}
#endif

static UINT32 ping_taskid = 0;
static int ping_kill = 0;
#define PING_ZERO_DATA_LEN 8
static void
lwip_ping_usage(void)
{
#ifndef CUSTOM_AT_COMMAND
  PRINTK("Usage:"\
         "\n  ping"
         "\n  ping [-n cnt] [-w interval] [-l data_len] destination"
         "\n  ping [-t] [-w interval] destination"
         "\n  ping -k");
  PRINTK("\n  -t means ping forever, user can use -k to stop the forever ping");
#endif
}

struct ping_run_ctx {
  int sfd;
  struct sockaddr_in to;
  struct icmp_echo_hdr *iecho;
  struct icmp_echo_hdr *iecho_resp;
  struct ip_hdr *iphdr_resp;
  u32_t iecho_len;
  s16_t ip_hlen;
  u32_t forever;
  u32_t i;
  u32_t succ_cnt;
  u32_t failed_cnt;
#if LWIP_LITEOS_TASK
  u64_t start_us;
  u64_t end_us;
  u64_t timout_end_us;
#else
  u32_t start_ms;
  u32_t end_ms;
  u32_t timout_end_ms;
#endif

#ifdef CUSTOM_AT_COMMAND
  s32_t rtt_sum;
  s32_t rtt_ave;
#endif

  s32_t timout_ms;
#if LWIP_EXT_POLL_SUPPORT
  struct pollfd pfd;
#else
  fd_set read_set;
  struct timeval time_val;
#endif
  s32_t rtt;
  int ret;
  u32_t intrvl;
  char *data_buf;
  BOOL timeout_flag;
  u32_t destip;
  u32_t cnt;
  u32_t interval;
  u32_t data_len;
};

LWIP_STATIC void
ping_req_init(struct ping_run_ctx *ctx)
{
  u32_t i;
  if (ctx->data_len > PING_ZERO_DATA_LEN) {
    (void)memset_s(ctx->iecho, sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN, 0,
                   sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN);
    ctx->data_buf = (char *)ctx->iecho + sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN;
    for (i = 0; i < ctx->data_len - PING_ZERO_DATA_LEN; i++) {
      *(ctx->data_buf + i) = i + 0x10;
    }
  } else {
    (void)memset_s(ctx->iecho, sizeof(struct icmp_echo_hdr) + ctx->data_len, 0,
                   sizeof(struct icmp_echo_hdr) + ctx->data_len);
  }
#if LWIP_LITEOS_TASK
  ctx->iecho->id = htons((u16_t)LOS_CurTaskIDGet());
#endif
  ICMPH_TYPE_SET(ctx->iecho, (u8_t)ICMP_ECHO);
}

LWIP_STATIC int
ping_ctx_init(struct ping_run_ctx *ctx, u32_t destip, u32_t cnt,
              u32_t interval, u32_t data_len)
{
  ctx->iecho = NULL;
  ctx->iecho_resp = NULL;
  ctx->iphdr_resp = NULL;
  ctx->succ_cnt = 0;
  ctx->failed_cnt = 0;

#ifdef CUSTOM_AT_COMMAND
  ctx->rtt_sum = 0;
#endif
  ctx->ret = 0;
  ctx->data_buf = NULL;
  ctx->timeout_flag = false;
  ctx->destip = destip;
  ctx->cnt = cnt;
  ctx->interval = interval;
  ctx->data_len = data_len;

  ctx->iecho_len = sizeof(struct icmp_echo_hdr) + data_len;
  ctx->iphdr_resp = (struct ip_hdr *)mem_malloc(ctx->iecho_len + IP_HLEN_MAX);
  if (ctx->iphdr_resp == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: pbuf_resp malloc failed\n");
#else
    PRINTK("Ping: pbuf_resp malloc failed\n");
#endif
    ctx->ret = -1;
    return -1;
  }
  ctx->iecho = (struct icmp_echo_hdr *)mem_malloc(ctx->iecho_len);
  if (ctx->iecho == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: echo request malloc failed\n");
#else
    PRINTK("Ping: echo request malloc failed\n");
#endif
    ctx->ret = -1;
    return -1;
  }
  ctx->to.sin_family = AF_INET;
  ctx->to.sin_addr.s_addr = ctx->destip; /* already in network order */
  ctx->to.sin_port = 0;
  ctx->forever = (cnt ? 0 : 1);
  ctx->i = 0;
  ping_req_init(ctx);
  return 0;
}


LWIP_STATIC void
ping_resp_code_print(u8_t iecho_resp)
{
  const char *print_str = NULL;
  LWIP_STATIC const char *icmp_code_str[] = {
    "icmp reply", // ICMP_ER
    NULL,
    NULL,
    "destination host unreachable", // ICMP_DUR
    "source quench", // ICMP_SQ
    "redirect", // ICMP_RD
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "time exceeded", // ICMP_TE
    "parameter problem" // ICMP_PP
  };

  if (iecho_resp < LWIP_ARRAYSIZE(icmp_code_str)) {
    print_str = icmp_code_str[iecho_resp];
  }

  if (print_str == NULL) {
    print_str = "unknow error";
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("\nPing: %s ...", print_str);
#else
  PRINTK("\nPing: %s ...", print_str);
#endif
}

LWIP_STATIC void
ping_resp_process(struct ping_run_ctx *ctx, u8_t iecho_resp)
{
  if (iecho_resp == ICMP_ER) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("\n[%u]Reply from %s: ", ctx->i, inet_ntoa(ctx->to.sin_addr));
    if (ctx->rtt < 1) {
      (void)hi_at_printf("time<1 ms ");
    } else {
      (void)hi_at_printf("time=%i ms ", ctx->rtt);
    }
    (void)hi_at_printf("TTL=%u", ctx->iphdr_resp->_ttl);
#else
    PRINTK("\n[%u]Reply from %s: ", ctx->i, inet_ntoa(ctx->to.sin_addr));
    if (ctx->rtt < 1) {
      PRINTK("time<1 ms ");
    } else {
      PRINTK("time=%i ms ", ctx->rtt);
    }
    PRINTK("TTL=%u", ctx->iphdr_resp->_ttl);
#endif

    /* delay 1s for every successful ping */
    ctx->intrvl = ctx->interval;
    do {
      if (ctx->intrvl < MS_PER_SECOND) {
        sys_msleep(ctx->intrvl);
        break;
      }
      ctx->intrvl -= MS_PER_SECOND;
      sys_msleep(MS_PER_SECOND);
      if (ping_kill == 1) {
        break;
      }
    } while (ctx->intrvl > 0);
    ctx->succ_cnt++;
#ifdef CUSTOM_AT_COMMAND
    if (ctx->rtt >= 1) {
      ctx->rtt_sum += ctx->rtt;
    }
#endif
  } else {
    ping_resp_code_print(ICMPH_TYPE(ctx->iecho_resp));
    ctx->failed_cnt++;
  }
}

LWIP_STATIC void
ping_rcv_rtt_calc(struct ping_run_ctx *ctx)
{
#if LWIP_LITEOS_TASK
  ctx->timout_end_us = hi_get_us();
  if (ctx->timout_end_us < ctx->start_us) {
    /* Incase of wraparoud of ticks */
    ctx->rtt = (s32_t)(ctx->timout_end_us / US_PER_MSECOND + ((LWIP_MAX_TICK_U64 - ctx->start_us) / US_PER_MSECOND));
  } else {
    ctx->rtt = (s32_t)(ctx->timout_end_us / US_PER_MSECOND - ctx->start_us / US_PER_MSECOND);
  }
#else
  ctx->timout_end_ms = sys_now();
  ctx->rtt = (s32_t)(ctx->timout_end_ms - ctx->start_ms);
  if (ctx->rtt < 0) {
    ctx->rtt = (s32_t)(ctx->timout_end_ms + (LWIP_MAX_TICK - ctx->start_ms));
  }
#endif
}

LWIP_STATIC int
ping_rcv_check(struct ping_run_ctx *ctx)
{
  if (ctx->ret < sizeof(struct icmp_echo_hdr) + IP_HLEN) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping : recv echo reply failed\n");
#else
    perror("Ping: recv echo reply failed\n");
#endif
    return -1;
  }

  /* Accessing ip header and icmp header */
  ctx->ip_hlen = (IPH_HL(ctx->iphdr_resp) << 2);
  if (ctx->ret < sizeof(struct icmp_echo_hdr) + ctx->ip_hlen) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping : recv echo reply failed\n");
#else
    perror("Ping: recv echo reply failed\n");
#endif
    return -1;
  }

  return 0;
}

LWIP_STATIC int
ping_rcv_poll(struct ping_run_ctx *ctx)
{
#if LWIP_EXT_POLL_SUPPORT
  /* poll for ICMP echo response msg */
  ctx->pfd.fd = ctx->sfd;
  ctx->pfd.events = POLLIN;
  ctx->pfd.revents = 0;
  return poll(&ctx->pfd, 1, LWIP_SHELL_CMD_PING_TIMEOUT);
#else
  /* Wait in select for ICMP response msg */
  FD_ZERO(&ctx->read_set);
  FD_SET(ctx->sfd, &ctx->read_set);
  ctx->time_val.tv_sec = LWIP_SHELL_CMD_PING_TIMEOUT / MS_PER_SECOND;
  ctx->time_val.tv_usec = 0;
  return lwip_select(ctx->sfd + 1, &ctx->read_set, 0, 0, &ctx->time_val);
#endif
}

LWIP_STATIC int
ping_rcv(struct ping_run_ctx *ctx)
{
  /* capture the start ms to calculate RTT */
#if LWIP_LITEOS_TASK
  ctx->start_us = hi_get_us();
#else
  ctx->start_ms = sys_now();
#endif

  do {
    ctx->timeout_flag = false;

    ctx->ret = ping_rcv_poll(ctx);
    if (ctx->ret < 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("ping : poll/select failure\n");
#else
      PRINTK("ping : poll/select failure\n");
#endif
      return -1;
    } else if (ctx->ret == 0) {
      /* first type timeout event */
      ctx->timeout_flag = true;
      break;
    }

retry:
    /* construct timeout event if poll lose efficacy when other host ping us */
    ctx->ret = recv(ctx->sfd, ctx->iphdr_resp, ctx->iecho_len + IP_HLEN_MAX, MSG_DONTWAIT);
    if (ping_rcv_check(ctx) == 0) {
      ctx->iecho_resp = (struct icmp_echo_hdr *)((char *)ctx->iphdr_resp + ctx->ip_hlen);
      if ((ctx->iphdr_resp->src.addr != ctx->to.sin_addr.s_addr) ||
          ((ICMPH_TYPE(ctx->iecho_resp) == ICMP_ECHO) && (ctx->iphdr_resp->src.addr == ctx->to.sin_addr.s_addr))) {
        /* second type timeout event */
        ping_rcv_rtt_calc(ctx);
        ctx->timout_ms = LWIP_SHELL_CMD_PING_TIMEOUT - ctx->rtt;
      } else {
        ctx->timout_ms = 0;
        break;
      }
    }
  } while (ctx->timout_ms >= 0);

  /* all timeout events are true timeout */
  if ((ctx->timout_ms < 0) || (ctx->timeout_flag == true)) {
    ctx->i++;
    ctx->failed_cnt++;
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("\nPing: destination unreachable ...\n");
#else
    PRINTK("\nPing: destination unreachable ...");
#endif
    return -1;
  }

  ping_rcv_rtt_calc(ctx);
  /* capture the end ms to calculate round trip time */
  if (ctx->iphdr_resp->src.addr == ctx->to.sin_addr.s_addr) {
    ping_resp_process(ctx, ICMPH_TYPE(ctx->iecho_resp));
    ctx->i++;
  } else {
    goto retry;
  }
  return 0;
}

LWIP_STATIC void
ping_result_print(struct ping_run_ctx *ctx)
{
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("\r\n%u packets transmitted, %u received, %u loss", ctx->i, ctx->succ_cnt, ctx->failed_cnt);

  if (ctx->succ_cnt > 0) {
    ctx->rtt_ave = ctx->rtt_sum / (s32_t)ctx->succ_cnt;
    if (ctx->rtt_ave < 1) {
      (void)hi_at_printf(", average time <1 ms.\r\n");
    } else {
      (void)hi_at_printf(", average time %i ms.\r\n", ctx->rtt_ave);
    }
  }

  (void)hi_at_printf("\r\nOK\r\n");
#else
  PRINTK("\n--- %s ping statistics ---\n", inet_ntoa(ctx->to.sin_addr));
  PRINTK("%u packets transmitted, %u received, %u loss\n", ctx->i, ctx->succ_cnt, ctx->failed_cnt);
  PRINTK("\r\nOK\r\n");
#endif
}

/* as this is not an internal function removing static keyword */
LWIP_STATIC int
osPingFunc(u32_t destip, u32_t cnt, u32_t interval, u32_t data_len)
{
  struct ping_run_ctx ctx;

  if ((ctx.sfd = lwip_socket(PF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping socket create fail \n");
#else
    perror("Ping socket");
#endif
    return -1;
  }

  if (ping_ctx_init(&ctx, destip, cnt, interval, data_len) != 0) {
    goto FAILURE;
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("+PING:");
#endif

  while ((ping_kill == 0) && ((ctx.forever != 0) || (ctx.i < cnt))) {
    ctx.iecho->seqno = htons((u16_t)ctx.i);
    ctx.iecho->chksum = 0;
    ctx.iecho->chksum = inet_chksum((void *)ctx.iecho, ctx.iecho_len);
    ctx.ret = sendto(ctx.sfd, ctx.iecho, ctx.iecho_len, 0, (struct sockaddr *)&ctx.to, (socklen_t)sizeof(ctx.to));
    if (ctx.ret < 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("Ping: sending ICMP echo request failed\n");
#else
      perror("Ping: sending ICMP echo request failed\n");
#endif
      goto FAILURE;
    }

    (void)ping_rcv(&ctx);
  }

  ping_result_print(&ctx);
FAILURE:
  ping_kill = 0;
  (void)lwip_close(ctx.sfd);
  if (ctx.iphdr_resp != NULL) {
    mem_free(ctx.iphdr_resp);
  }
  if (ctx.iecho != NULL) {
    mem_free(ctx.iecho);
  }
  return ctx.ret;
}

#if LWIP_LITEOS_TASK
static void
ping_cmd(unsigned int p0, unsigned int p1, unsigned int p2, unsigned int p3)
{
  u32_t destip = p0;
  u32_t count = p1;
  u32_t interval = p2;
  u32_t data_len = p3;
  int ret;

  ret = osPingFunc(destip, count, interval, data_len);
  if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping cmd failed due some errors\n");
#else
    PRINTK("Ping cmd failed due some errors\n");
#endif
  }

  ping_taskid = 0;
}
#endif

#ifdef CUSTOM_AT_COMMAND
u32_t
ping_get_ip_value(const char *cmd, char *arg, u32_t arg_len, u32_t *cmd_offset)
{
    const char *cmd_copy = cmd;
    u32_t pos = 0;
    if ((cmd == NULL) || (arg == NULL) || (cmd_offset == NULL)) {
      return LOS_NOK;
    }
    while (*cmd_copy == '.') {
        ++cmd_copy;
    }

    while ((*cmd_copy != '.') && (*cmd_copy != '\0')) {
        arg[pos] = *cmd_copy;
        ++pos;
        ++cmd_copy;
        if (pos >= arg_len) {
            return LOS_NOK;
        }
    }
    arg[pos] = '\0';

    if (pos == 0) {
        return LOS_NOK;
    }

    *cmd_offset = (u32_t)(cmd_copy - cmd);
    return LOS_OK;
}
#endif

struct ping_cfg_handle {
  const char *key;
  u32_t *data;
  int min;
  int max;
  int arg_num;
};

LWIP_STATIC int
ping_cfg_parse_daddr(const char *daddr, ip4_addr_t *dst_ipaddr)
{
  /* initialize dst IP address */
#if LWIP_DNS
  dst_ipaddr->addr = get_hostip(daddr);
#else /* LWIP_DNS */
  dst_ipaddr->addr = inet_addr(daddr);
#endif /* LWIP_DNS */

  if (dst_ipaddr->addr == IPADDR_NONE || dst_ipaddr->addr == IPADDR_ANY) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Invalid dest ipaddr: %s\n", daddr);
#else
    PRINTK("Invalid dest ipaddr: %s\n", daddr);
#endif
    return -1;
  }

  return 0;
}

LWIP_STATIC int
ping_cfg_parse(int argc, const char **argv, u32_t *count, u32_t *interval, u32_t *data_len,
               ip4_addr_t *dst_ipaddr, u32_t *ping_kill_flag)
{
  u32_t ping_forever = 0;
  u32_t i = 0;
  u32_t j = 0;
  int ret;
  struct ping_cfg_handle handle[] = {
    {
      .key = "-n",
      .data = count,
      .min = 1,
      .max = INT_MAX,
      .arg_num = 1,
    },
    {
      .key = "-t",
      .data = &ping_forever,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 0,
    },
    {
      .key = "-w",
      .data = interval,
      .min = 1,
      .max = INT_MAX,
      .arg_num = 1,
    },
    {
      .key = "-l",
      .data = data_len,
      .min = 0,
      .max = (int)(LWIP_MAX_UDP_RAW_SEND_SIZE - sizeof(struct icmp_echo_hdr)),
      .arg_num = 1,
    },
    {
      .key = "-k",
      .data = ping_kill_flag,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 0,
    }
  };
  *count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
  /* could add more param support */
  while (argc > 0) {
    u8_t match = 0;
    for (j = 0; j < LWIP_ARRAYSIZE(handle); j++) {
      if (strcmp(argv[i], handle[j].key) == 0) {
        if (handle[j].arg_num > argc) {
          goto param_error;
        }

        if (handle[j].arg_num == 0) {
          *(handle[j].data) = 1;
        } else {
          ret = atoi(argv[i + 1]);
          if (ret < handle[j].min || ret > handle[j].max) {
#ifdef CUSTOM_AT_COMMAND
            (void)hi_at_printf("Ping %s arg error, should be in range of [%d, %d] \n",
                               handle[j].key, handle[j].min, handle[j].max);
#else
            PRINTK("Ping %s arg error, should be in range of [%d, %d] \n",
                   handle[j].key, handle[j].min, handle[j].max);
#endif
            return -1;
          }
          *(handle[j].data) = (u32_t)ret;
        }
        i += handle[j].arg_num + 1;
        argc -= handle[j].arg_num + 1;
        match = 1;
        break;
      }
    }

    if (match == 0 && argc > 1) {
      goto param_error;
    } else if (*ping_kill_flag == 1) {
      return 0;
    } else if (argc <= 1) {
      break;
    }
  }

  if (argc != 1) {
param_error:
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Invalid Ping param\n");
#else
    PRINTK("Invalid Ping param\n");
#endif
    return -1;
  }

  if (ping_cfg_parse_daddr(argv[i], dst_ipaddr) == -1) {
    return -1;
  }

  if (ping_forever == 1) {
    *count = 0;
  }
  return 0;
}

#if LWIP_LITEOS_TASK
LWIP_STATIC u32_t ping_task_create(u32_t count, u32_t interval, u32_t data_len,
                                   ip4_addr_t dst_ipaddr, u16_t prio)
{
  UINT32 los_ret;
  TSK_INIT_PARAM_S st_ping_task;

  /* start one task if ping forever or ping count greater than 60 */
  if (ping_taskid > 0) {
    (void)hi_at_printf("Ping task already running and only support one now\n");
    return LOS_NOK;
  }
  st_ping_task.pfnTaskEntry = (TSK_ENTRY_FUNC)ping_cmd;
  st_ping_task.uwStackSize  = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
  st_ping_task.pcName = "ping_task";
  st_ping_task.usTaskPrio = prio; /* equal lwip */
  st_ping_task.uwResved = LOS_TASK_STATUS_DETACHED;
  st_ping_task.auwArgs[0] = dst_ipaddr.addr; /* network order */
  st_ping_task.auwArgs[1] = count;
  st_ping_task.auwArgs[2] = interval; /* 2 : ping interval */
  st_ping_task.auwArgs[3] = data_len; /* 3 : ping data len */
  los_ret = LOS_TaskCreate((UINT32 *)(&ping_taskid), &st_ping_task);
  if (LOS_OK != los_ret) {
    (void)hi_at_printf("ping_task create failed 0x%08x.\n", los_ret);
    return los_ret;
  }
  return LOS_OK;
}
#endif

LWIP_STATIC u32_t ping_exec(u32_t count, u32_t interval, u32_t data_len,
                            ip4_addr_t dst_ipaddr)
{
#ifdef CUSTOM_AT_COMMAND
#if LWIP_LITEOS_TASK
    return ping_task_create(count, interval, data_len, dst_ipaddr, 5);
#endif
#else
#if LWIP_LITEOS_TASK
  /* start one task if ping forever or ping count greater than 60 */
  if ((count == 0) || (count > LWIP_SHELL_CMD_PING_RETRY_TIMES)) {
    if (ping_task_create(count, interval, data_len, dst_ipaddr, 4) == LOS_NOK && ping_taskid == 0) {
      PRINTK("ping_task create failed 0x%08x.\n", los_ret);
      count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
    } else {
      return LOS_OK;
    }
  }
#endif
  /* two cases:
   1, ping cout less than LWIP_SHELL_CMD_PING_RETRY_TIMES;
   2, ping task create failed;
  */
  if (osPingFunc(dst_ipaddr.addr, count, interval, data_len) < 0) {
    PRINTK("Ping cmd failed due some errors\n");
    return LOS_NOK;
  }

  return LOS_OK;
#endif
}

u32_t
osShellPing(int argc, const char **argv)
{
  u32_t count = 0;
  u32_t interval = 1000; /* default ping interval */
  u32_t data_len = 48; /* default data length */
  ip4_addr_t dst_ipaddr;
  u32_t ping_kill_flag = 0;

  if (tcpip_init_finish == 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("%s: tcpip_init have not been called\n", __FUNCTION__);
#else
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
#endif
    return LOS_NOK;
  }

  if ((argc < 1) || (argv == NULL)) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: require dest ipaddr at least \n");
#else
    PRINTK("Ping: require dest ipaddr at least \n");
#endif
    goto ping_error;
  }
  if (ping_cfg_parse(argc, argv, &count, &interval, &data_len, &dst_ipaddr, &ping_kill_flag) == -1) {
    goto ping_error;
  }

  if (ping_kill_flag == 1) {
    if (ping_taskid > 0) {
      ping_kill = 1; /* stop the current ping task */
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("+PING:\r\nOK\r\n");
#endif
      return (int)LOS_OK;
    } else {
      PRINTK("No ping task running...\n");
      return (int)LOS_NOK;
    }
  }

  return ping_exec(count, interval, data_len, dst_ipaddr);
ping_error:
  lwip_ping_usage();
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ping_shellcmd, CMD_TYPE_EX, "ping", XARGS, (CmdCallBackFunc)osShellPing);
#endif /* LOSCFG_SHELL */

#if LWIP_DNS
#ifdef CUSTOM_AT_COMMAND
u32_t osShellshowDns(void)
{
    ip_addr_t dns;
    err_t err;
    int i;
    (void)hi_at_printf("+DNS:\r\n");
    for (i = 0; i < DNS_MAX_SERVERS; i++) {
      err = lwip_dns_getserver((u8_t)i, &dns);
      if (err == ERR_OK) {
        (void)hi_at_printf("%s\r\n", ipaddr_ntoa_unsafe(&dns));
      } else {
          return LOS_NOK;
      }
    }
    (void)hi_at_printf("OK\r\n");
    return LOS_OK;
}
#endif
#endif

#if LWIP_DNS
u32_t
osShellDns(int argc, const char **argv)
{
  ip_addr_t dns;
  err_t err;
  int i;

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }
  if (argv == NULL) {
    return LOS_NOK;
  }

  if ((argc == 1) && (strcmp(argv[0], "-a") == 0)) {
    for (i = 0; i < DNS_MAX_SERVERS; i++) {
      err = lwip_dns_getserver((u8_t)i, &dns);
      if (err == ERR_OK) {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("dns %d: %s\n", i + 1, ipaddr_ntoa_unsafe(&dns));
#else
        PRINTK("dns %d: %s\n", i + 1, ipaddr_ntoa_unsafe(&dns));
#endif
      } else {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("dns: failed\n");
#else
        PRINTK("dns: failed\n");
#endif
        return LOS_NOK;
      }
    }
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("OK\r\n");
#endif
    return LOS_OK;
  } else if (argc == 2) { /* 2 : current argc index */
    i = atoi(argv[0]);
    if ((i <= 0) || (i > DNS_MAX_SERVERS)) {
      goto usage;
    }
#if LWIP_IPV6
    if (ip6addr_aton(argv[1], ((ip6_addr_t *)&dns))) {
#if LWIP_IPV4 && LWIP_IPV6
      dns.type = IPADDR_TYPE_V6;
#endif
#ifdef LWIP_DNS_GLOBAL_ADDR
      if (!ip6_addr_isglobal((ip6_addr_t *)&dns)) {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("ip address<%s> is wrong\n", argv[1]);
#else
        PRINTK("ip address<%s> is wrong\n", argv[1]);
#endif
        return LOS_NOK;
      }
#endif
    } else
#endif
    {
#if LWIP_IPV4
      ((ip4_addr_t *)&dns)->addr = ipaddr_addr(argv[1]);
      if (((ip4_addr_t *)&dns)->addr == IPADDR_NONE) {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("ip address<%s> is wrong\n", argv[1]);
#else
        PRINTK("ip address<%s> is wrong\n", argv[1]);
#endif
        return LOS_NOK;
      }
#if LWIP_IPV4 && LWIP_IPV6
      dns.type = IPADDR_TYPE_V4;
#endif
#endif
    }

    err = lwip_dns_setserver((u8_t)(i - 1), &dns);
    if (err != ERR_OK) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("dns : failed\n");
#else
      PRINTK("dns : failed\n");
#endif
      return LOS_NOK;
    }
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("OK\r\n");
#endif
    return LOS_OK;
  }
usage:
#ifndef CUSTOM_AT_COMMAND
  PRINTK("usage:\n");
  PRINTK("\tdns <1-%d> <IP>\n", DNS_MAX_SERVERS);
  PRINTK("\tdns -a\n");
#endif
  return LOS_NOK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(dns_shellcmd, CMD_TYPE_EX, "dns", XARGS, (CmdCallBackFunc)osShellDns);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_DNS */

#if LWIP_DHCP
err_t dhcp_idx_to_mac(const struct netif *netif, dhcp_num_t mac_idx, u8_t *hwaddr, u8_t *hwaddr_len);
#define MACADDR_BUF_LEN 32
static void
dhcp_client_info_show(struct dhcp_client *dhcp)
{
  ip4_addr_t cli_ip;
  struct dhcp_state *dhcp_state = &((dhcp->states)[dhcp->cli_idx]);
  char macaddr[MACADDR_BUF_LEN];
  char *char_p = macaddr;
  u8_t i;
  u8_t state;

  (void)memset_s(macaddr, sizeof(macaddr), 0, sizeof(macaddr));
  for (i = 0; i < dhcp_state->hwaddr_len; i++) {
    /* 2 : macaddr show in two hex */
    (void)snprintf_s(char_p, (size_t)(MACADDR_BUF_LEN - 2 * i), (size_t)(MACADDR_BUF_LEN - 2 * i - 1),
                     "%02x", dhcp->hwaddr[i]);
    /* 2 : skip two index */
    char_p = char_p + 2;
  }
  DHCP_HOST_TO_IP(cli_ip.addr, ip_2_ip4(&dhcp->server_ip_addr)->addr, dhcp->offered_sn_mask.addr,
                  dhcp_state->offered_ip_addr);
  state = dhcp_state->state;
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("\t%-16"DHCP_NUM_F"%-16s%-16s%-16hhu%-16hu\n", dhcp_state->idx, macaddr,
                 (dhcp_state->offered_ip_addr == 0) ? "0.0.0.0" : ip4addr_ntoa(&cli_ip),
                 state, dhcp_state->lease_used);
#else
  PRINTK("\t%-16"DHCP_NUM_F"%-16s%-16s%-16hhu%-16hu\n", dhcp_state->idx, macaddr,
           (dhcp_state->offered_ip_addr == 0) ? "0.0.0.0" : ip4addr_ntoa(&cli_ip),
           state, dhcp_state->lease_used);
#endif

  return;
}

void
dhcp_clients_info_show(struct netif *netif_p)
{
  struct dhcp *netif_dhcp = NULL;
  struct dhcp_client *dhcp = NULL;
  struct dhcp_state *dhcp_state = NULL;
  int i;
  u8_t hwaddr_len;
  if (netif_p == NULL) {
    return;
  }
  netif_dhcp = netif_dhcp_data(netif_p);
  if (netif_dhcp == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("dhcpc not start on %s%hhu\n", netif_p->name, netif_p->num);
#else
    PRINTK("dhcpc not start on %s%hhu\n", netif_p->name, netif_p->num);
#endif
    return;
  }
  dhcp = &(netif_dhcp->client);
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("server :\n");
  (void)hi_at_printf("\tserver_id : %s\n", ip4addr_ntoa(ip_2_ip4(&(dhcp->server_ip_addr))));
  (void)hi_at_printf("\tmask : %s, %hhu\n", ip4addr_ntoa(&(dhcp->offered_sn_mask)), dhcp->subnet_mask_given);
  (void)hi_at_printf("\tgw : %s\n", ip4addr_ntoa(&(dhcp->offered_gw_addr)));
  (void)hi_at_printf("\tT0 : %u\n", dhcp->offered_t0_lease);
  (void)hi_at_printf("\tT1 : %u\n", dhcp->offered_t1_renew);
  (void)hi_at_printf("\tT2 : %u\n", dhcp->offered_t2_rebind);
#else
  PRINTK("server :\n");
  PRINTK("\tserver_id : %s\n", ip4addr_ntoa(ip_2_ip4(&(dhcp->server_ip_addr))));
  PRINTK("\tmask : %s, %hhu\n", ip4addr_ntoa(&(dhcp->offered_sn_mask)), dhcp->subnet_mask_given);
  PRINTK("\tgw : %s\n", ip4addr_ntoa(&(dhcp->offered_gw_addr)));
  PRINTK("\tT0 : %u\n", dhcp->offered_t0_lease);
  PRINTK("\tT1 : %u\n", dhcp->offered_t1_renew);
  PRINTK("\tT2 : %u\n", dhcp->offered_t2_rebind);
#endif
  if (ip4_addr_isany_val(dhcp->server_ip_addr.u_addr.ip4)) {
    return;
  }

#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("clients <%"DHCP_NUM_F"> :\n", dhcp->cli_cnt);
  (void)hi_at_printf("\t%-16s%-16s%-16s%-16s%-16s\n", "mac_idx", "mac", "addr", "state", "lease_used");
#else
  PRINTK("clients <%"DHCP_NUM_F"> :\n", dhcp->cli_cnt);
  PRINTK("\t%-16s%-16s%-16s%-16s%-16s\n", "mac_idx", "mac", "addr", "state", "lease_used");
#endif
  for (i = 0; i < DHCP_CLIENT_NUM; i++) {
    dhcp->cli_idx = (dhcp_num_t)i;
    dhcp_state = &((dhcp->states)[i]);
    if ((i != LWIP_DHCP_NATIVE_IDX) && (dhcp_state->idx == 0)) {
      continue;
    }
    if (dhcp_idx_to_mac(netif_p, dhcp_state->idx, dhcp->hwaddr, &hwaddr_len) != ERR_OK) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("<%d> idx %"DHCP_NUM_F" to mac failed\n", i, dhcp_state->idx);
#else
      PRINTK("<%d> idx %"DHCP_NUM_F" to mac failed\n", i, dhcp_state->idx);
#endif
      continue;
    }
    dhcp_state->hwaddr_len = hwaddr_len;
    dhcp_client_info_show(dhcp);
  }

  return;
}

u32_t
osShellDhcp(int argc, const char **argv)
{
  int ret = 0;
  struct netif *netif_p = NULL;

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  if ((argc != 2) || (argv == NULL)) { /* 2 : total argc num */
    goto usage;
  }

  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    PRINTK("no such netif named %s\n", argv[0]);
    goto usage;
  }
#ifdef CUSTOM_AT_COMMAND
    if (strcmp(argv[1], "1") == 0) {
        ret = netifapi_dhcp_start(netif_p);
    } else if (strcmp(argv[1], "0") == 0) {
        ret = netifapi_dhcp_stop(netif_p);
    } else {
        goto usage;
    }
#else
  if (strcmp(argv[1], "start") == 0) {
    ret = netifapi_dhcp_start(netif_p);
  } else if (strcmp(argv[1], "stop") == 0) {
    ret = netifapi_dhcp_stop(netif_p);
  } else if (strcmp(argv[1], "inform") == 0) {
    ret = netifapi_dhcp_inform(netif_p);
  } else if (strcmp(argv[1], "renew") == 0) {
    ret = netifapi_dhcp_renew(netif_p);
  } else if (strcmp(argv[1], "release") == 0) {
    ret = netifapi_dhcp_release(netif_p);
  } else if (strcmp(argv[1], "show") == 0) {
    ret = netifapi_netif_common(netif_p, dhcp_clients_info_show, NULL);
  } else {
    goto usage;
  }
#endif
  if (ret == LOS_OK) {
    PRINTK("OK\r\n");
  }

  return (ret == 0) ? LOS_OK : LOS_NOK;
usage:
#ifndef CUSTOM_AT_COMMAND
  PRINTK("dhcp\n\tifname {start | stop | inform | renew | release | show}\n");
#endif
  return LOS_NOK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(dhcp_shellcmd, CMD_TYPE_EX, "dhcp", XARGS, (CmdCallBackFunc)osShellDhcp);
#endif /* LOSCFG_SHELL */

#if LWIP_DHCPS
void
dhcps_info_show(struct netif *netif)
{
  struct dhcps *dhcps = NULL;
  struct dyn_lease_addr *lease = NULL;
  int i, j, k = 0;
  ip4_addr_t addr;

  if (netif == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("dhcps_info_show null netif\r\n");
#else
    PRINTK("dhcps_info_show null netif\r\n");
#endif
    return;
  }

  dhcps = netif->dhcps;

  if ((dhcps == NULL) || (dhcps->pcb == NULL)) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("dhcps of %s%hhu not start\r\n", netif->name, netif->num);
#else
    PRINTK("dhcps of %s%hhu not start\r\n", netif->name, netif->num);
#endif
    return;
  }
  addr.addr = lwip_htonl(dhcps->start_addr.addr);
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("start ip : %s\r\n", ip4addr_ntoa(&addr));
#else
  PRINTK("start ip : %s\r\n", ip4addr_ntoa(&addr));
#endif
  addr.addr = lwip_htonl(dhcps->end_addr.addr);
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("end ip : %s\r\n", ip4addr_ntoa(&addr));
    (void)hi_at_printf("lease num %hhu\r\n", dhcps->lease_num);
    (void)hi_at_printf("sys_now %u\r\n", sys_now());
#else
    PRINTK("end ip : %s\r\n", ip4addr_ntoa(&addr));
    PRINTK("lease num %hhu\r\n", dhcps->lease_num);
    PRINTK("sys_now %u\r\n", sys_now());
#endif

  for (i = 0; i < dhcps->lease_num; i++) {
    if (dhcps->leasearr[i].flags != 0) {
      lease = &(dhcps->leasearr[i]);
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("%d : ", k++);
#else
      PRINTK("%d : ", k++);
#endif
      for (j = 0; j < NETIF_MAX_HWADDR_LEN; j++) {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("%02x", lease->cli_hwaddr[j]);
#else
        PRINTK("%02x", lease->cli_hwaddr[j]);
#endif
      }
      addr.addr = lwip_htonl(lease->cli_addr.addr);
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf(" %s leasetime = %u(%u), proposed_leasetime = %u\r\n", ip4addr_ntoa(&addr), lease->leasetime,
                         (lease->leasetime - sys_now()) / US_PER_MSECOND, lease->proposed_leasetime);
#else
      PRINTK(" %s leasetime = %u(%u), proposed_leasetime = %u\r\n", ip4addr_ntoa(&addr), lease->leasetime,
             (lease->leasetime - sys_now()) / US_PER_MSECOND, lease->proposed_leasetime);
#endif
    }
  }
}

u32_t
osShellDhcps(int argc, const char **argv)
{
  int ret = 0;
  struct netif *netif_p = NULL;

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  if ((argc != 2) || (argv == NULL)) { /* 2 : totol argc num */
    goto usage;
  }

  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    PRINTK("no such netif named %s\n", argv[0]);
    goto usage;
  }
#ifdef CUSTOM_AT_COMMAND
    if (strcmp(argv[1], "1") == 0) {
        ret = netifapi_dhcps_start(netif_p, NULL, 0);
    } else if (strcmp(argv[1], "0") == 0) {
        ret = netifapi_dhcps_stop(netif_p);
    } else {
        goto usage;
    }
#else
  if (strcmp(argv[1], "start") == 0) {
    ret = netifapi_dhcps_start(netif_p, NULL, 0);
  } else if (strcmp(argv[1], "stop") == 0) {
    ret = netifapi_dhcps_stop(netif_p);
  } else if (strcmp(argv[1], "show") == 0) {
    ret = netifapi_netif_common(netif_p, dhcps_info_show, NULL);
  } else {
    goto usage;
  }
#endif
  if (ret == LOS_OK) {
    PRINTK("OK\r\n");
  }

  return (ret == 0) ? LOS_OK : LOS_NOK;
usage:
#ifndef CUSTOM_AT_COMMAND
  PRINTK("dhcps\n\tifname {start | stop | show}\n");
#endif
  return LOS_NOK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(dhcps_shellcmd, CMD_TYPE_EX, "dhcps", XARGS, (CmdCallBackFunc)osShellDhcps);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_DHCPS */
#endif /* LWIP_DHCP */

#if LWIP_IPV6
extern struct nd6_neighbor_cache_entry neighbor_cache[LWIP_ND6_NUM_NEIGHBORS];
#endif
#if LWIP_IPV6
int
netstat_get_udp_sendQLen6(struct udp_pcb *udppcb, struct pbuf *udpbuf)
{
  int send_len = -1;
  u16_t offset = 0, len;
  struct ip6_hdr *iphdr = NULL;
  struct udp_hdr *udphdr = NULL;
  struct ip6_dest_hdr *dest_hdr = NULL;
  struct ip6_frag_hdr *frag_hdr = NULL;
  u8_t nexth;
  u16_t hlen = 0;

  LWIP_ERROR("netstat_get_udp6_sendQLen: NULL pcb received\n", (udppcb != NULL), return -1);
  LWIP_ERROR("netstat_get_udp6_sendQLen: NULL pbuf received\n", (udpbuf != NULL), return -1);

  iphdr = (struct ip6_hdr *)udpbuf->payload;
  LWIP_ERROR("netstat_get_udp6_sendQLen: NULL iphdr received\n", (iphdr != NULL), return -1);
  if (!(ip6_addr_cmp(&iphdr->dest, ip_2_ip6(&udppcb->remote_ip)) &&
        (ip_addr_isany(&udppcb->local_ip) ||
         ip_get_option(udppcb, SOF_BINDNONUNICAST) ||
         ip6_addr_cmp(&iphdr->src, ip_2_ip6(&udppcb->local_ip))))) {
    goto FUNC_OUT;
  }

  len = IP6_HLEN;
  if (pbuf_header(udpbuf, (s16_t)(-(s16_t)(len)))) {
    goto FUNC_OUT;
  }

  offset = len;

  nexth = IP6H_NEXTH(iphdr);
  while (offset < udpbuf->tot_len) {
    if ((nexth == IP6_NEXTH_NONE) || (nexth == IP6_NEXTH_UDP) || (nexth == IP6_NEXTH_UDPLITE)) {
      break;
    }
    switch (nexth) {
      case IP6_NEXTH_HOPBYHOP:
      case IP6_NEXTH_ROUTING:
        nexth = *((u8_t *)udpbuf->payload);
        /* 8 : hlen will Multiply by 8 in ipv6 option segment */
        hlen = (u16_t)(8 * (1 + *((u8_t *)udpbuf->payload + 1)));
        break;
      case IP6_NEXTH_DESTOPTS:
        nexth = *((u8_t *)udpbuf->payload);
        dest_hdr = (struct ip6_dest_hdr *)udpbuf->payload;
        /* 8 : hlen will Multiply by 8 in ipv6 option segment */
        hlen = (u16_t)(8 * (1 + dest_hdr->_hlen));
        break;
      case IP6_NEXTH_FRAGMENT:
        frag_hdr = (struct ip6_frag_hdr *)udpbuf->payload;
        nexth = frag_hdr->_nexth;
        hlen = IP6_FRAG_HLEN;
        break;
      default:
        /* Unknown next_header */
        goto FUNC_OUT;
    }

    (void)pbuf_header(udpbuf, (s16_t)(-(s16_t)hlen));
    offset = (u16_t)(offset + hlen);
  }

  /* If the while loop test condition failed , then revert the last offset change */
  if (offset >= udpbuf->tot_len) {
    offset = (u16_t)(offset - hlen);
    goto FUNC_OUT;
  }

  LWIP_ERROR("Transport option should be UDP", (nexth == IP6_NEXTH_UDP || nexth == IP6_NEXTH_UDPLITE), goto FUNC_OUT);

  if (offset > iphdr->_plen) {
    goto FUNC_OUT;
  }

  /* check if there is enough space for atleast udp header available */
  if (udpbuf->tot_len < UDP_HLEN) {
    goto FUNC_OUT;
  }

  udphdr = (struct udp_hdr *)udpbuf->payload;
  if ((ntohs(udphdr->dest) == udppcb->remote_port) && (ntohs(udphdr->src) == udppcb->local_port)) {
    if (ntohs(udphdr->len) > UDP_HLEN) {
      send_len = ntohs(udphdr->len) - UDP_HLEN;
    } else {
      send_len = udpbuf->tot_len - UDP_HLEN;
    }
  }

FUNC_OUT:
  (void)pbuf_header(udpbuf, (s16_t)offset); // canot not cross max limit of s16_t
  return send_len;
}
#endif

#if LWIP_IPV4
int
netstat_get_udp_sendQLen(struct udp_pcb *udppcb, struct pbuf *udpbuf)
{
  int send_len = -1;
  u16_t offset = 0, len;
  struct ip_hdr *iphdr = NULL;
  struct udp_hdr *udphdr = NULL;

  LWIP_ERROR("netstat_get_udp_sendQLen: NULL pcb received\n", (udppcb != NULL), return -1);
  LWIP_ERROR("netstat_get_udp_sendQLen: NULL pbuf received\n", (udpbuf != NULL), return -1);

  iphdr = (struct ip_hdr *)udpbuf->payload;

  if (!(ip4_addr_cmp(&iphdr->dest, ip_2_ip4(&udppcb->remote_ip))
        && (ip_addr_isany(&udppcb->local_ip) ||
            ip_get_option(udppcb, SOF_BINDNONUNICAST) ||
            ip4_addr_cmp(&iphdr->src, ip_2_ip4(&udppcb->local_ip))))) {
    goto FUNC_OUT;
  }
#if LWIP_UDPLITE
  if ((IPH_PROTO(iphdr) != IP_PROTO_UDP) && (IPH_PROTO(iphdr) != IP_PROTO_UDPLITE))
#else
  if (IPH_PROTO(iphdr) != IP_PROTO_UDP)
#endif
  {
    goto FUNC_OUT;
  }

  if ((ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) != 0) {
    goto FUNC_OUT;
  }

  len = (u16_t)(IPH_HL(iphdr) * 4); /* 4 ：IP Header Length Multiply by 4 */
  if (pbuf_header(udpbuf, (s16_t)(-len))) {
    goto FUNC_OUT;
  }

  offset = (u16_t)(offset + len);

  udphdr = (struct udp_hdr *)udpbuf->payload;
  if ((ntohs(udphdr->dest) == udppcb->remote_port) && (ntohs(udphdr->src) == udppcb->local_port)) {
    send_len = ntohs(udphdr->len) - UDP_HLEN;
  }

FUNC_OUT:
  (void)pbuf_header(udpbuf, (s16_t)offset);
  return send_len;
}
#endif

int
netstat_tcp_recvq(struct tcp_pcb *tpcb)
{
  unsigned int ret_val = 0;
#if LWIP_SO_RCVBUF
  struct netconn *conn = NULL;
#endif

  LWIP_ERROR("netstat_tcp_recvq: Received NULL pcb\n", (tpcb != NULL), return 0);

#if LWIP_SO_RCVBUF
  conn = (struct netconn *)tpcb->callback_arg;
  if (conn != NULL) {
    switch (conn->type) {
      case NETCONN_TCP:
      case NETCONN_RAW:
#if LWIP_IPV6
      case NETCONN_RAW_IPV6:
      case NETCONN_UDP_IPV6:
#endif
      case NETCONN_UDP:
        SYS_ARCH_GET(((unsigned int)conn->recv_avail + conn->lrcv_left), ret_val);
        break;
      default:
        ret_val = 0; /* ur... very ugly, damn DHCP DNS and SNTP */
    }
  }
#endif

  return (int)ret_val;
}

int
netstat_tcp_sendq(struct tcp_pcb *tpcb)
{
  int ret_val = 0;
  struct tcp_seg *useg = NULL;

  LWIP_ERROR("netstat_tcp_sendq: Received NULL pcb\n", (tpcb != NULL), return 0);

  for (useg = tpcb->unacked; useg != NULL; useg = useg->next) {
    ret_val = ret_val + useg->len;
  }

  return ret_val;
}

#if LWIP_IPV6
int
netstat_udp_sendq6(struct udp_pcb *upcb)
{
  int ret_len = 0, ret;
  int idx = 0;
  int i;
#if LWIP_ND6_QUEUEING
  struct nd6_q_entry *neibq = NULL;
#endif

  LWIP_ERROR("netstat_udp_sendq6: Received NULL pcb\n", (upcb != NULL), return 0);

  for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
    if (neighbor_cache[i].state != ND6_NO_ENTRY) {
      if (ip6_addr_cmp(&upcb->remote_ip.u_addr.ip6, &neighbor_cache[i].next_hop_address)) {
        idx = i;
        break;
      }
    }
  }
#if LWIP_ND6_QUEUEING
  for (neibq = neighbor_cache[idx].q; neibq != NULL; neibq = neibq->next) {
    if (neibq->p == NULL) {
      return 0;
    }
    ret = netstat_get_udp_sendQLen6(upcb, neibq->p);
    if (ret >= 0) {
      ret_len += ret;
    }
  }
#else
  ret = netstat_get_udp_sendQLen6(upcb, neighbor_cache[idx].q);
  if (ret >= 0) {
    ret_len += ret;
  }
#endif
  return ret_len;
}
#endif

#if LWIP_IPV4
int
netstat_udp_sendq(struct udp_pcb *upcb)
{
  int ret_len = 0, ret;
  int arpidx = -1;
  int i;
#if ARP_QUEUEING
  struct etharp_q_entry *arpq = NULL;
#endif

  LWIP_ERROR("netstat_udp_sendq: Received NULL pcb\n", (upcb != NULL), return 0);

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    if (arp_table[i].state != ETHARP_STATE_EMPTY) {
      if (ip4_addr_cmp(ip_2_ip4(&upcb->remote_ip), &arp_table[i].ipaddr)) {
        arpidx = i;
        break;
      }
    }
  }

  if (arpidx >= 0) {
#if ARP_QUEUEING
    for (arpq = arp_table[arpidx].q; arpq != NULL; arpq = arpq->next) {
      ret = netstat_get_udp_sendQLen(upcb, arpq->p);
      if (ret <= 0) {
        continue;
      }
      ret_len += ret;
      if (ret_len <= 0) { // overflow, set rteLen = -1 to indicate
        ret_len = -1;
        break;
      }
    }
#else
    ret = netstat_get_udp_sendQLen(upcb, arp_table[arpidx].q);
    if (ret > 0) {
      ret_len += ret;
      if (ret_len <= 0) { // overflow, set rteLen = -1 to indicate
        ret_len = -1;
      }
    }
#endif
  }
  return ret_len;
}
#endif
int
netstat_netconn_recvq(const struct netconn *conn)
{
  unsigned int ret_val = 0;

#if LWIP_SO_RCVBUF
  if (conn == NULL) {
    return 0;
  }

  switch (NETCONNTYPE_GROUP(conn->type)) {
    case NETCONN_TCP:
    case NETCONN_RAW:
#if PF_PKT_SUPPORT
    case NETCONN_PKT_RAW:
#endif
    case NETCONN_UDP:
      SYS_ARCH_GET(((unsigned int)conn->recv_avail + conn->lrcv_left), ret_val);
      break;
    default:
      ret_val = 0; /* ur... very ugly, damn DHCP DNS and SNTP */
  }
#else
  (void)conn;
#endif
  return (int)ret_val;
}
int
netstat_netconn_sendq(struct netconn *conn)
{
  int ret_val;

  if (conn == NULL) {
    return 0;
  }

  switch (NETCONNTYPE_GROUP(conn->type)) {
    case NETCONN_TCP:
      ret_val = netstat_tcp_sendq(conn->pcb.tcp);
      break;
    case NETCONN_RAW:
      ret_val = 0;
      break;
#if PF_PKT_SUPPORT
    case NETCONN_PKT_RAW:
      ret_val = 0; /* always be 0 as frame send to driver directly */
      break;
#endif
    case NETCONN_UDP:
      ret_val = netstat_udp_sendq(conn->pcb.udp);
      break;
    default:
      ret_val = 0; /* ur... very ugly, damn DHCP DNS and SNTP */
  }

  return ret_val;
}

#ifndef CUSTOM_AT_COMMAND
#if PF_PKT_SUPPORT
static s32_t
print_netstat_pkt_raw(struct netstat_data *ndata, u32_t *entry_buf_offset)
{
  u8_t netif_name[IFNAMSIZ];
  struct netif *netif = NULL;
  s8_t *entry_buf = ndata->netstat_out_buf;
  u32_t entry_buf_len = ndata->netstat_out_buf_len;
  int recv_qlen, send_qlen, i_ret;
#ifndef CUSTOM_AT_COMMAND
  u_int proto;
  struct raw_pcb *rpcb = NULL;
#endif
  if (entry_buf == NULL) {
    goto out;
  }
  if (pkt_raw_pcbs != NULL) {
    i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                       "\n%-12s%-12s%-12s%-16s%-12s\n", "Type", "Recv-Q", "Send-Q", "Protocol", "netif");
    if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
      goto out;
    }
    entry_buf_len -= (u32_t)(i_ret);
    (*entry_buf_offset) += (u32_t)(i_ret);

    for (rpcb = pkt_raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
      recv_qlen = netstat_netconn_recvq(rpcb->recv_arg);
      send_qlen = netstat_netconn_sendq(rpcb->recv_arg);
      for (netif = netif_list; netif != NULL; netif = netif->next) {
        if (netif->ifindex != rpcb->netifindex) {
          continue;
        }
        i_ret = snprintf_s((char *)netif_name, IFNAMSIZ, IFNAMSIZ - 1, "%s%d", netif->name, netif->num);
        if ((i_ret <= 0) || ((u32_t)(i_ret) >= IFNAMSIZ)) {
          goto out;
        }
        break;
      }

      if (netif == NULL) {
        (void)snprintf_s((char *)netif_name, IFNAMSIZ, IFNAMSIZ - 1, "%s", "None");
      }

      proto = ntohs(rpcb->proto.eth_proto);

      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "%-12s%-12d%-12d%-16x%-12s\n", "pkt-raw", recv_qlen, send_qlen, proto, netif_name);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }
  }
  ndata->netstat_out_buf_len = entry_buf_len;
  return ERR_OK;
out:
  return ERR_VAL;
}
#endif

#if LWIP_RAW
static s32_t
print_netstat_raw(struct netstat_data *ndata, u32_t *entry_buf_offset)
{
#ifndef CUSTOM_AT_COMMAND
  u_int proto;
  struct raw_pcb *rpcb = NULL;
#endif
  s8_t local_ip_port[64] = {0};
  s8_t remote_ip_port[64] = {0};
  s8_t *entry_buf = ndata->netstat_out_buf;
  u32_t entry_buf_len = ndata->netstat_out_buf_len;
  int recv_qlen, send_qlen, i_ret;
  if (entry_buf == NULL) {
    goto out;
  }
  if (raw_pcbs != NULL) {
    i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                       "\n%-8s%-12s%-12s%-20s%-20s%-16s%-16s\n",
                       "Type", "Recv-Q", "Send-Q", "Local Address", "Foreign Address", "Protocol", "HDRINCL");
    if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
      goto out;
    }
    entry_buf_len -= (u32_t)(i_ret);
    (*entry_buf_offset) += (u32_t)(i_ret);

    for (rpcb = raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s",
                         ipaddr_ntoa(&rpcb->local_ip));
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s",
                         ipaddr_ntoa(&rpcb->remote_ip));
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }

      recv_qlen = netstat_netconn_recvq(rpcb->recv_arg);
      send_qlen = netstat_netconn_sendq(rpcb->recv_arg);

      proto = rpcb->raw_proto;
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "%-8s%-12d%-12d%-20s%-20s%-16u%-16d\n", "raw",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, proto, rpcb->hdrincl);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }
  }
  ndata->netstat_out_buf_len = entry_buf_len;
#if PF_PKT_SUPPORT
  s32_t pkt_ret = print_netstat_pkt_raw(ndata, entry_buf_offset);
  if (pkt_ret == ERR_VAL) {
    goto out;
  }
#endif
  return ERR_OK;
out:
  return ERR_VAL;
}
#endif
#endif

#if LWIP_UDP
static s32_t
print_netstat_udp(struct netstat_data *ndata, u32_t *entry_buf_offset)
{
  s8_t local_ip_port[64] = {0};
  s8_t remote_ip_port[64] = {0};
  struct udp_pcb *upcb = NULL;
  s8_t *entry_buf = ndata->netstat_out_buf;
  u32_t entry_buf_len = ndata->netstat_out_buf_len;
  int recv_qlen, send_qlen, i_ret;
  if (entry_buf == NULL) {
    goto out;
  }
  if (udp_pcbs != NULL) {
#ifndef CUSTOM_AT_COMMAND
    i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                       "\n%-8s%-12s%-12s%-24s%-24s\n", "Proto", "Recv-Q", "Send-Q", "Local Address", "Foreign Address");
    if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
      goto out;
    }
    entry_buf_len -= (u32_t)(i_ret);
    (*entry_buf_offset) += (u32_t)(i_ret);
#endif

    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&upcb->local_ip), upcb->local_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&upcb->remote_ip), upcb->remote_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }

      recv_qlen = (upcb->recv == recv_udp) ? netstat_netconn_recvq(upcb->recv_arg) : 0;
#if LWIP_IPV6
      send_qlen = IP_IS_V6(&upcb->local_ip) ? netstat_udp_sendq6(upcb) : ((upcb->recv == recv_udp) ? \
                                                                          netstat_netconn_sendq(upcb->recv_arg) : 0);
#else
      send_qlen = (upcb->recv == recv_udp) ? netstat_netconn_sendq(upcb->recv_arg) : 0;
#endif
      if (entry_buf_len <= 1) {
        return ERR_VAL;
      }
#ifdef CUSTOM_AT_COMMAND
      /* Proto 2:udp-ip6; 3:udp */
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "+NETSTAT:%d,%d,%d,%s,%s,%d\r\n",
                         (IP_IS_V6(&upcb->local_ip) ? UDP_IP6 : UDP), recv_qlen, send_qlen, local_ip_port,
                         remote_ip_port, 0);
#else
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         (IP_IS_V6(&upcb->local_ip) ? "%-8s%-12d%-12d%-39s%-39s%-16s\n" :
                          "%-8s%-12d%-12d%-24s%-24s%-16s\n"),
                         IP_IS_V6(&upcb->local_ip) ? "udp-ip6" : "udp",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, " ");
#endif
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }
  }
  ndata->netstat_out_buf_len = entry_buf_len;
  return ERR_OK;
out:
  return ERR_VAL;
}
#endif

#if LWIP_TCP
static s32_t
print_netstat_tcp(struct netstat_data *ndata, u32_t *entry_buf_offset)
{
  s8_t local_ip_port[64] = {0};
  s8_t remote_ip_port[64] = {0};
  struct tcp_pcb *tpcb = NULL;
  struct tcp_pcb_listen *lpcb = NULL;
  s8_t *entry_buf = ndata->netstat_out_buf;
  u32_t entry_buf_len = ndata->netstat_out_buf_len;
  int recv_qlen, send_qlen, i_ret;
  if (entry_buf == NULL) {
    goto out;
  }
  if ((tcp_active_pcbs != NULL) || (tcp_bound_pcbs != NULL) ||
      (tcp_tw_pcbs != NULL) || (tcp_listen_pcbs.pcbs != NULL)) {
#ifndef CUSTOM_AT_COMMAND
    i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                       "%-8s%-12s%-12s%-24s%-24s%-16s\n",
                       "Proto", "Recv-Q", "Send-Q", "Local Address", "Foreign Address", "State");
    if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
      goto out;
    }
    entry_buf_len -= (u32_t)(i_ret);
    (*entry_buf_offset) += (u32_t)(i_ret);
#endif
    for (tpcb = tcp_active_pcbs; tpcb != NULL; tpcb = tpcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->local_ip), tpcb->local_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->remote_ip), tpcb->remote_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }
      if (tpcb->state == SYN_RCVD) {
        recv_qlen = 0;
        send_qlen = 0;
      } else {
        recv_qlen = netstat_netconn_recvq(tpcb->callback_arg);
        send_qlen = netstat_netconn_sendq(tpcb->callback_arg);
      }

#ifdef CUSTOM_AT_COMMAND
      /* Proto 0:tcp-ip6; 1:tcp .State for tcp_state_str */
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "+NETSTAT:%d,%d,%d,%s,%s,%d\r\n",
                         (IP_IS_V6(&tpcb->local_ip) ? TCP_IP6 : TCP), recv_qlen, send_qlen, local_ip_port,
                         remote_ip_port, tpcb->state);
#else
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         (IP_IS_V6(&tpcb->local_ip) ? "%-8s%-12d%-12d%-39s%-39s%-16s\n" :
                          "%-8s%-12d%-12d%-24s%-24s%-16s\n"),
                         IP_IS_V6(&tpcb->local_ip) ? "tcp-ip6" : "tcp",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, tcp_state_str[tpcb->state]);
#endif
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }

    /* For bound PCBs */
    send_qlen = 0;
    recv_qlen = 0;

    for (tpcb = tcp_bound_pcbs; tpcb != NULL; tpcb = tpcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->local_ip), tpcb->local_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->remote_ip), tpcb->remote_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }

#ifdef CUSTOM_AT_COMMAND
      /* Proto 0:tcp-ip6; 1:tcp .State for tcp_state_str */
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "+NETSTAT:%d,%d,%d,%s,%s,%d\r\n",
                         (IP_IS_V6(&tpcb->local_ip) ? TCP_IP6 : TCP), recv_qlen, send_qlen,
                         local_ip_port, remote_ip_port, tpcb->state);
#else
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         (IP_IS_V6(&tpcb->local_ip) ? "%-8s%-12d%-12d%-39s%-39s%-16s\n" :
                          "%-8s%-12d%-12d%-24s%-24s%-16s\n"),
                         IP_IS_V6(&tpcb->local_ip) ? "tcp-ip6" : "tcp",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, tcp_state_str[tpcb->state]);
#endif
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }

    for (tpcb = tcp_tw_pcbs; tpcb != NULL; tpcb = tpcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->local_ip), tpcb->local_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&tpcb->remote_ip), tpcb->remote_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }

      recv_qlen = netstat_netconn_recvq(tpcb->callback_arg);
      send_qlen = netstat_netconn_sendq(tpcb->callback_arg);

#ifdef CUSTOM_AT_COMMAND
      /* Proto  0:tcp-ip6;  1:tcp .Proto  0:tcp-ip6;  1:tcp .State for tcp_state_str */
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "+NETSTAT:%d,%d,%d,%s,%s,%d\r\n",
                         (IP_IS_V6(&tpcb->local_ip) ? TCP_IP6 : TCP), recv_qlen, send_qlen, local_ip_port,
                         remote_ip_port, tpcb->state);
#else
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         (IP_IS_V6(&tpcb->local_ip) ? "%-8s%-12d%-12d%-39s%-39s%-16s\n" :
                          "%-8s%-12d%-12d%-24s%-24s%-16s\n"),
                         IP_IS_V6(&tpcb->local_ip) ? "tcp-ip6" : "tcp",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, tcp_state_str[tpcb->state]);
#endif
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }

    /* For listen PCBs */
    recv_qlen = 0;
    send_qlen = 0;

    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      i_ret = snprintf_s((char *)local_ip_port, sizeof(local_ip_port), (sizeof(local_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&lpcb->local_ip), lpcb->local_port);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(local_ip_port))) {
        goto out;
      }

      i_ret = snprintf_s((char *)remote_ip_port, sizeof(remote_ip_port), (sizeof(remote_ip_port) - 1), "%s:%d",
                         ipaddr_ntoa(&lpcb->remote_ip), 0);
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= sizeof(remote_ip_port))) {
        goto out;
      }

      recv_qlen = netstat_netconn_recvq(lpcb->callback_arg);

#ifdef CUSTOM_AT_COMMAND
      /* Proto  0:tcp-ip6;  1:tcp .Proto  0:tcp-ip6;  1:tcp .State for tcp_state_str */
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         "+NETSTAT:%d,%d,%d,%s,%s,%d\r\n",
                         (IP_IS_V6(&lpcb->local_ip) ? TCP_IP6 : TCP), recv_qlen, send_qlen, local_ip_port,
                         remote_ip_port, lpcb->state);
#else
      i_ret = snprintf_s((char *)(entry_buf + (*entry_buf_offset)), entry_buf_len, entry_buf_len - 1,
                         (IP_IS_V6(&lpcb->local_ip) ? "%-8s%-12d%-12d%-39s%-39s%-16s\n" :
                          "%-8s%-12d%-12d%-24s%-24s%-16s\n"),
                         IP_IS_V6(&lpcb->local_ip) ? "tcp-ip6" : "tcp",
                         recv_qlen, send_qlen, local_ip_port, remote_ip_port, tcp_state_str[lpcb->state]);
#endif
      if ((i_ret <= 0) || ((u32_t)(i_ret) >= entry_buf_len)) {
        goto out;
      }
      entry_buf_len -= (u32_t)(i_ret);
      (*entry_buf_offset) += (u32_t)(i_ret);
    }
  }
  ndata->netstat_out_buf_len = entry_buf_len;
  return ERR_OK;
out:
  return ERR_VAL;
}
#endif

void
netstat_internal(void *ctx)
{
  s8_t *entry_buf = NULL;
  u32_t entry_buf_offset = 0;
  struct netstat_data *ndata = (struct netstat_data *)ctx;
  entry_buf = ndata->netstat_out_buf;

  if (entry_buf == NULL) {
    goto out;
  }

#ifndef CUSTOM_AT_COMMAND
  int i_ret;
  i_ret = snprintf_s((char *)(entry_buf), ndata->netstat_out_buf_len, ndata->netstat_out_buf_len - 1,
                     "========== total sockets %d ======  unused sockets %d ==========\n", LWIP_CONFIG_NUM_SOCKETS,
                     get_unused_socket_num());
  if ((i_ret <= 0) || ((u32_t)(i_ret) >= ndata->netstat_out_buf_len)) {
    goto out;
  }
  ndata->netstat_out_buf_len -= (u32_t)(i_ret);
  entry_buf_offset = (u32_t)(i_ret);
#endif
#if LWIP_TCP
  s32_t tcp_ret = print_netstat_tcp(ndata, &entry_buf_offset);
  if (tcp_ret == ERR_VAL) {
    goto out;
  }
#endif
#if LWIP_UDP
  s32_t udp_ret = print_netstat_udp(ndata, &entry_buf_offset);
  if (udp_ret == ERR_VAL) {
    goto out;
  }
#endif
#ifndef CUSTOM_AT_COMMAND
#if LWIP_RAW
  s32_t raw_ret = print_netstat_raw(ndata, &entry_buf_offset);
  if (raw_ret == ERR_VAL) {
    goto out;
  }
#endif
#endif
out:
  ndata->netstat_out_buf_updated_len = entry_buf_offset;
  sys_sem_signal(&ndata->cb_completed);
  return;
}

static void
print_netstat_out_buf_updated_len(struct netstat_data *ndata)
{
  u32_t print_len = 0;
  char print_out_buff[MAX_PRINT_SIZE] = {0};
  if (ndata->netstat_out_buf_updated_len < MAX_PRINT_SIZE) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("%s", (char *)(ndata->netstat_out_buf));
#else
    PRINTK("%s\n", (char *)(ndata->netstat_out_buf));
#endif
  } else {
    do {
      (void)memset_s(print_out_buff, sizeof(print_out_buff), 0x0, sizeof(print_out_buff));
      (void)memcpy_s(print_out_buff, sizeof(print_out_buff) - 1, ndata->netstat_out_buf + print_len,
                     sizeof(print_out_buff) - 1);
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("%s", print_out_buff);
#else
       PRINTK("%s", print_out_buff);
#endif
       ndata->netstat_out_buf_updated_len -= sizeof(print_out_buff) - 1;
       print_len += sizeof(print_out_buff) - 1;
    } while (ndata->netstat_out_buf_updated_len >= (MAX_PRINT_SIZE - 1));

    if (ndata->netstat_out_buf_updated_len > 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("%s", (char *)(ndata->netstat_out_buf + print_len));
#else
       PRINTK("%s", (char *)(ndata->netstat_out_buf + print_len));
#endif
    }
    PRINTK("\n");
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("OK\r\n");
#endif
}

u32_t
osShellNetstat(int argc, char **argv)
{
  struct netstat_data ndata;
  err_t err;

  if (argc > 0) {
    PRINTK("\nUsage: netstat\n");
    return LOS_NOK;
  }

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }
  (void)memset_s(&ndata, sizeof(struct netstat_data), 0, sizeof(struct netstat_data));
  ndata.netstat_out_buf = mem_malloc(MAX_NETSTAT_ENTRY);
  if (ndata.netstat_out_buf == NULL) {
    PRINTK("%s: no free mem\n", __FUNCTION__);
    return LOS_NOK;
  }
  ndata.netstat_out_buf_len = MAX_NETSTAT_ENTRY;
  ndata.netstat_out_buf_updated_len = 0;

  if (sys_sem_new(&ndata.cb_completed, 0) != ERR_OK) {
    goto err_hand;
  }

  err = tcpip_callback(netstat_internal, &ndata);
  if (err != ERR_OK) {
    sys_sem_free(&ndata.cb_completed);
    goto err_hand;
  }

  (void)sys_arch_sem_wait(&ndata.cb_completed, 0);
  sys_sem_free(&ndata.cb_completed);
  if ((ndata.netstat_out_buf_updated_len > 0) && (ndata.netstat_out_buf_updated_len < MAX_NETSTAT_ENTRY)) {
    print_netstat_out_buf_updated_len(&ndata);
    mem_free(ndata.netstat_out_buf);
    return LOS_OK;
  } else if (ndata.netstat_out_buf_updated_len >= MAX_NETSTAT_ENTRY) {
    goto err_hand;
  } else {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("OK\r\n");
#endif
    mem_free(ndata.netstat_out_buf);
    return LOS_OK;
  }

err_hand:
  mem_free(ndata.netstat_out_buf);
  ndata.netstat_out_buf = NULL;
  (void)(argv);
  return LOS_NOK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(netstat_shellcmd, CMD_TYPE_EX, "netstat",  XARGS, (CmdCallBackFunc)osShellNetstat);
#endif /* LOSCFG_SHELL */

#if LWIP_IPV6
#define PING6_TASK_PRIO  5
static UINT32 ping6_taskid = 0;
static int ping6_kill = 0;
static void
ping6_cmd(unsigned int p0, unsigned int p1, unsigned int p2)
{
  u8_t type = (u8_t)p0;
  void *param = (void *)p1;
  ping6_args_t *ping6_params = NULL;
  ping6_params = (ping6_args_t *)p2;
  int ret;
  ret = os_ping_fun6(type, param, *ping6_params);
  if (ret != LOS_OK) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("ERROR\r\n");
#else
    PRINTK("Ping6 cmd failed due some errors\n");
#endif
  }
  ping6_taskid = 0;
}

static void
ping6_kill_op(const u32_t nsent, const u32_t nrecieve, const ping6_stats_t *ping6_stats_p,
#if LWIP_LITEOS_TASK
              const u64_t first_us
#else
              const u32_t first_tick
#endif
             )
{
  /* Display ping stats */
  if (nsent != 0) {
#ifdef CUSTOM_AT_COMMAND
    /* 100 : percentage conversion */
    (void)hi_at_printf("%u packets transmitted, %u received, %.2f%% packet loss,", nsent, nrecieve,
                       (float)(((float)(nsent - nrecieve)) * ((float)(100)) / ((float)(nsent))));
#else
    PRINTK("%u packets transmitted, %u received, %.2f%% packet loss,", nsent, nrecieve,
           (float)(((float)(nsent - nrecieve)) * ((float)(100)) / ((float)(nsent)))); /* 100 : percentage conversion */
#endif
#if LWIP_LITEOS_TASK
    (void)hi_at_printf("time %ums\n", (u32_t)((hi_get_us() - first_us) / US_PER_MSECOND));
#else
    PRINTK("time %ums\n", (u32_t)((sys_now() - first_tick)));
#endif
  }
  if (nrecieve != 0) {
    /* Display rtt stats only if atleast one packet is recieved */
#ifndef CUSTOM_AT_COMMAND
    PRINTK("rtt min/avg/max = %u/%.2f/%u ms\n", ping6_stats_p->min_rtt, ping6_stats_p->avg_rtt, ping6_stats_p->max_rtt);
#else
    (void)ping6_stats_p;
#endif
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("OK\r\n");
#endif
}

static int
prepare_icmpv6_head(struct icmp6_echo_hdr *iecho, struct pbuf *pbuf_req, u16_t *icmpv6_seq_p, u16_t icmpv6_id,
#if LWIP_LITEOS_TASK
                    u64_t start_us
#else
                    u32_t start_tick
#endif
                   )
{
  iecho->type = ICMP6_TYPE_EREQ;
  iecho->id = icmpv6_id;
  (*icmpv6_seq_p)++;
  iecho->seqno = lwip_htons(*icmpv6_seq_p);
  iecho->code = 0;

  /* Embedding the start_tick as data into the icmp_payload */
  (void)pbuf_header(pbuf_req, (s16_t)(-(s16_t)(sizeof(struct icmp6_echo_hdr))));
#if LWIP_LITEOS_TASK
  if (memcpy_s(pbuf_req->payload, pbuf_req->len, (void *)&start_us, sizeof(start_us)) != EOK) {
#else
  if (memcpy_s(pbuf_req->payload, pbuf_req->len, (void *)&start_tick, sizeof(start_tick)) != EOK) {
#endif
    return -1;
  }
  (void)pbuf_header(pbuf_req, (s16_t)((s16_t)(sizeof(struct icmp6_echo_hdr))));
  return 0;
}

static void
ping6_reduce_timeout(struct timeval *delta_time_p, struct timeval *st_time_p,
#if LWIP_LITEOS_TASK
                      u64_t start_us, u64_t end_us
#else
                      u32_t start_tick, u32_t end_tick
#endif
                     )
{
  /* If incoming packet does not matches with icmp_id, it should be ignored  */
  /* Reduce the timeout for select on socket */
#if LWIP_LITEOS_TASK
  delta_time_p->tv_sec = (long)(((end_us - start_us) / US_PER_MSECOND) / MS_PER_SECOND);
  delta_time_p->tv_usec = (long)((end_us - start_us));
#else
  delta_time_p->tv_sec = (long)((end_tick - start_tick) / US_PER_MSECOND);
  delta_time_p->tv_usec = (long)((end_tick - start_tick) % MS_PER_SECOND);
#endif
  /* Subtract deltaTime from stTime and store in stTime */
  /* This will reduce the select time on the socket */
  timersub(st_time_p, delta_time_p, st_time_p);
}

static void
ping6_release_resource(int sfd, struct pbuf *pbuf_resp, struct pbuf *pbuf_req)
{
  ping6_kill = 0;
  if (sfd != -1) {
    (void)lwip_close(sfd);
    sfd = -1;
  }

  if (pbuf_resp != NULL) {
    (void)pbuf_free(pbuf_resp);
    pbuf_resp = NULL;
  }

  if (pbuf_req != NULL) {
    (void)pbuf_free(pbuf_req);
    pbuf_req = NULL;
  }
}

static void
ping6_calc_rtt(s32_t *rtt,
#if LWIP_LITEOS_TASK
               u64_t end_us, u64_t data_start_us
#else
               u32_t end_tick, u32_t data_start_tick
#endif
               )
{
#if LWIP_LITEOS_TASK
  if (end_us < data_start_us) {
    /* Incase of wraparoud of ticks */
    *rtt = (s32_t)(end_us / US_PER_MSECOND + ((LWIP_MAX_TICK_U64 - data_start_us) / US_PER_MSECOND));
  } else {
    *rtt = (s32_t)(end_us / US_PER_MSECOND - data_start_us / US_PER_MSECOND);
  }
#else
  *rtt = (s32_t)(end_tick - data_start_tick);
  if (*rtt < 0) {
    /* Incase of wraparoud of ticks */
    *rtt = (s32_t)(end_tick + (LWIP_MAX_TICK - data_start_tick));
  }
#endif
}

static void
ping6_print_rtt(const s32_t rtt, const int recv_nums, const struct icmp6_echo_hdr *iecho_resp,
                const struct sockaddr_in6 to)
{
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("%d bytes from %s : icmp_seq=%d time", recv_nums, inet6_ntoa(to.sin6_addr),
                     ((iecho_resp->seqno) - LWIP_PING6_STARTING_SEQ_NUM));
  if (rtt < 1) {
    (void)hi_at_printf("<1 ms\n");
  } else {
    (void)hi_at_printf("=%i ms\n", rtt);
  }
#else
  PRINTK("%d bytes from %s : icmp_seq=%d time", recv_nums, inet6_ntoa(to.sin6_addr), ((iecho_resp->seqno) - \
                                                                                LWIP_PING6_STARTING_SEQ_NUM));
  if (rtt < 1) {
    PRINTK("<1 ms\n");
  } else {
    PRINTK("=%i ms\n", rtt);
  }
#endif
}

static int
ping6_param_init(struct pbuf **pbuf_req, struct pbuf **pbuf_resp, struct sockaddr_in6 *to,
                 ping6_args_t ping6_params, ping6_stats_t *ping6_stats_p)
{
  *pbuf_req = pbuf_alloc(PBUF_RAW, LWIP_PING6_STANDARD_PKT_SIZE, PBUF_RAM);
  *pbuf_resp = pbuf_alloc(PBUF_RAW, LWIP_PING6_STANDARD_PKT_SIZE, PBUF_RAM);
  if ((*pbuf_resp == NULL) || (*pbuf_req == NULL)) {
    PRINTK("ping6 : Memory Allocation Failed\n");
    return -1;
  }

  to->sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
  (void)memcpy_s((&to->sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                 (&(ping6_params.dst_addr))->addr, sizeof(struct ip6_addr));
#else
  inet6_addr_from_ip6addr(&to->sin6_addr, &(ping6_params.dst_addr));
#endif
  to->sin6_port = htons(IPPROTO_ICMPV6);

  ping6_stats_p->flag = 0;
  ping6_stats_p->avg_rtt = 0;
  ping6_stats_p->max_rtt = 0;
  ping6_stats_p->min_rtt = 0;
  return 0;
}

LWIP_STATIC int
os_ping_fun6(u8_t type, void *param, ping6_args_t ping6_params)
{
  int ret = 0;
  u8_t select_on_socket;
  fd_set fd_read_set;
  u16_t icmpv6_id, icmpv6_seq;
  u32_t nsent, nrecieve, last_recieved;
#if LWIP_LITEOS_TASK
  u64_t start_us, end_us, data_start_us, first_us;
#else
  u32_t start_tick, end_tick, data_start_tick, first_tick;
#endif
  s32_t rtt;
  ping6_stats_t ping6_stats;
  struct sockaddr_in6 to;
  struct icmp6_echo_hdr *iecho_resp = NULL;
  struct icmp6_echo_hdr *iecho = NULL;
  struct timeval st_time_val, delta_time_val;
  struct pbuf *pbuf_resp = NULL;
  struct pbuf *pbuf_req = NULL;
  int sfd = -1;
  /* Create a socket for sending and receiving pings with appropriate bindings */
  sfd = create_ping6_socket(type, param);
  if (sfd == -1) {
    ret = -1;
    goto exit;
  }

  ret = ping6_param_init(&pbuf_req, &pbuf_resp, &to, ping6_params, &ping6_stats);
  if (ret == -1) {
    goto exit;
  }

  nrecieve = 0;
  last_recieved = LWIP_PING6_STARTING_SEQ_NUM + LWIP_PING6_OUT_OF_ORDER_MAGNITUDE + 1;
  icmpv6_id = (u16_t)LWIP_RAND();
  icmpv6_seq = LWIP_PING6_STARTING_SEQ_NUM;

  /* Setting the start time of the entire ping task for statistics */
#if LWIP_LITEOS_TASK
  first_us = hi_get_us();
#else
  first_tick = sys_now();
#endif

  for (nsent = 0; nsent < ping6_params.pingcount; nsent++) {
    if (ping6_kill == 1) {
      ret = ERR_OK;
      goto ping6_kill;
    }
    if (nsent != 0) {
      sys_msleep(MS_PER_SECOND);
    }
    /* capture the start tick to calculate rtt */
#if LWIP_LITEOS_TASK
    start_us = hi_get_us();
    /* Initialize Memory To Prevent Unintialized Memory Read Write Issues */
    (void)memset_s(pbuf_req->payload, pbuf_req->len, (int)(start_us), pbuf_req->len);
#else
    start_tick = sys_now();
    /* Initialize Memory To Prevent Unintialized Memory Read Write Issues */
    (void)memset_s(pbuf_req->payload, pbuf_req->len, (int)(start_tick), pbuf_req->len);
#endif
    iecho = (struct icmp6_echo_hdr *)pbuf_req->payload;
    ret = prepare_icmpv6_head(iecho, pbuf_req, &icmpv6_seq, icmpv6_id,
#if LWIP_LITEOS_TASK
                              start_us
#else
                              start_tick
#endif
                             );
    if (ret == -1) {
      goto exit;
    }

    ret = lwip_sendto(sfd, iecho, pbuf_req->len, 0, (struct sockaddr *)&to, (socklen_t)sizeof(to));
    if (ret == -1) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("ping6 : Sending ICMP Echo message failed\n");
#else
      PRINTK("ping6 : Sending ICMP Echo message failed\n");
#endif
      goto exit;
    }

    /* Wait in select for ICMP response msg */
    FD_ZERO(&fd_read_set);
    FD_SET(sfd, &fd_read_set);
    st_time_val.tv_sec = LWIP_MSECS_TO_SECS(LWIP_SHELL_CMD_PING_TIMEOUT);
    st_time_val.tv_usec = 0;
    select_on_socket = 1;

    while (select_on_socket == 1) {
      select_on_socket = 0;
      if (ping6_kill == 1) {
        ret = ERR_OK;
        goto ping6_kill;
      }
      ret = lwip_select(sfd + 1, &fd_read_set, 0, 0, &st_time_val);
      if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("ping6 : select failure\n");
#else
        PRINTK("ping6 : select failure\n");
#endif
        goto exit;
      } else if (ret == 0) {
#if LWIP_LITEOS_TASK
        end_us = hi_get_us();
#else
        end_tick = sys_now();
#endif
#ifdef CUSTOM_AT_COMMAND
        (void)hi_at_printf("Request timed out\n");
#else
        PRINTK("Request timed out\n");
#endif
        break;
      }

      /* capture the end tick to calculate round trip time */
#if LWIP_LITEOS_TASK
      end_us = hi_get_us();
#else
      end_tick = sys_now();
#endif

      ret = lwip_recv(sfd, pbuf_resp->payload, pbuf_resp->len, 0);
      if (ret == -1) {
        PRINTK("ping6 : receiving ICMP echo response msg failed\n");
        goto exit;
      }

      if ((size_t)ret < sizeof(struct icmp6_echo_hdr)) {
        /* Drop the packet if its too short [Doesnot contain even the header !!] */
        PRINTK("ping6 : received ICMP echo response too short\n");
        goto REDUCE_SELECT_TIME;
      }

      /* Acceping the ICMPv6 payload. */
      /* Here, pbuf_resp->payload wont contain IPv6 Header since its an AF_INET6 RAW Socket */
      iecho_resp = (struct icmp6_echo_hdr *)pbuf_resp->payload;
      iecho_resp->seqno = lwip_ntohs(iecho_resp->seqno);

      if (iecho_resp->id == icmpv6_id) {
        if (iecho_resp->type == ICMP6_TYPE_EREP) {
          if (ret < LWIP_PING6_STANDARD_PKT_SIZE) {
            /* Drop the packet if its too short */
            PRINTK("ping6 : received ICMP echo response too short\n");
            goto REDUCE_SELECT_TIME;
          }
          /* Accept and process only those delayed EREP only if its sequence num is within out-of-order magnitude */
          if (nsent && (iecho_resp->seqno != icmpv6_seq) &&
              ((iecho_resp->seqno <= (u16_t)(last_recieved - LWIP_PING6_OUT_OF_ORDER_MAGNITUDE)) ||
               (iecho_resp->seqno >= (u16_t)(last_recieved + LWIP_PING6_OUT_OF_ORDER_MAGNITUDE)))) {
            /* Otherwise drop it and wait for more packets */
            goto REDUCE_SELECT_TIME;
          }
          ++nrecieve;
          last_recieved = iecho_resp->seqno;
          /* Retrieving the start_tick from the packet which was embedded when the request was transmitted */
          (void)pbuf_header(pbuf_resp, (s16_t)(-(s16_t)(sizeof(struct icmp6_echo_hdr))));
#if LWIP_LITEOS_TASK
          if (memcpy_s((void *)&data_start_us, sizeof(data_start_us), pbuf_resp->payload,
                       sizeof(data_start_us)) != EOK) {
#else
          if (memcpy_s((void *)&data_start_tick, sizeof(data_start_tick), pbuf_resp->payload, LWIP_TICK_SIZE) != EOK) {
#endif
            goto exit;
          }
          (void)pbuf_header(pbuf_resp, (s16_t)((s16_t)(sizeof(struct icmp6_echo_hdr))));

          ping6_calc_rtt(&rtt,
#if LWIP_LITEOS_TASK
                         end_us, data_start_us
#else
                         end_tick, data_start_tick
#endif
                        );

          ping6_print_rtt(rtt, ret, iecho_resp, to);
          update_ping6_stats(&ping6_stats, (u32_t)(rtt), nrecieve);

          /* Checking if its a delayed packet */
          if ((iecho_resp->seqno != icmpv6_seq) && (nsent < ping6_params.pingcount)) {
            /* Incase of delayed packet wait on socket for other response before sending a new PING */
            /* We have to reduce the timeout value now when selecting on socket */
            goto REDUCE_SELECT_TIME;
          }
        } else {
#ifdef CUSTOM_AT_COMMAND
          (void)hi_at_printf("[%u]ping6 : %s\n", nsent, convert_icmpv6_err_to_string(iecho_resp->type));
#else
          PRINTK("[%u]ping6 : %s\n", nsent, convert_icmpv6_err_to_string(iecho_resp->type));
#endif
        }
      } else {
        /* If incoming packet does not matches with icmp_id, it should be ignored  */
        /* Reduce the timeout for select on socket */
REDUCE_SELECT_TIME:
        ping6_reduce_timeout(&delta_time_val, &st_time_val,
#if LWIP_LITEOS_TASK
                             start_us, end_us
#else
                             start_tick, end_tick
#endif
                            );
        select_on_socket = 1;
      }
    }
  }

  ret = ERR_OK;
ping6_kill:
  ping6_kill_op(nsent, nrecieve, &ping6_stats,
#if LWIP_LITEOS_TASK
                first_us
#else
                first_tick
#endif
               );

exit:
  ping6_release_resource(sfd, pbuf_resp, pbuf_req);
  return (u32_t)((ret == (int)ERR_OK) ? LOS_OK : LOS_NOK);
}

#if LWIP_LITEOS_TASK
static u32_t
start_ping6_task(const ping6_args_t *ping6_params_p, u8_t type, const void *param)
{
  TSK_INIT_PARAM_S st_ping_task;
  UINT32 los_ret;
  if (ping6_taskid > 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping6 task already running and only support one now\n");
#else
    PRINTK("Ping6 task already running and only support one now\n");
#endif
    return LOS_NOK;
  }
  st_ping_task.pfnTaskEntry = (TSK_ENTRY_FUNC)ping6_cmd;
  st_ping_task.uwStackSize  = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
  st_ping_task.pcName = "ping6_task";
  st_ping_task.usTaskPrio = PING6_TASK_PRIO; /* higher than shell */
  st_ping_task.uwResved = LOS_TASK_STATUS_DETACHED;
  st_ping_task.auwArgs[0] = (UINT32)type;
  st_ping_task.auwArgs[1] = (UINT32)param;
  st_ping_task.auwArgs[2] = (UINT32)ping6_params_p;
  los_ret = LOS_TaskCreate(&ping6_taskid, &st_ping_task);
  if (los_ret != LOS_OK) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6_task create failed 0x%08x.\n", los_ret);
#else
    PRINTK("ping6_task create failed 0x%08x.\n", los_ret);
#endif
    return LOS_NOK;
  } else {
    return LOS_OK;
  }
}
#endif /* LWIP_LITEOS_TASK */

static void
ping6_print_data(const ping6_args_t *ping6_params_p, const char *host_addr)
{
  struct sockaddr_in6 to;
  to.sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
  (void)memcpy_s((&to.sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                 (&(ping6_params_p->dst_addr))->addr, sizeof(struct ip6_addr));
#else
  inet6_addr_from_ip6addr(&to.sin6_addr, &(ping6_params_p->dst_addr));
#endif
  to.sin6_port = htons(IPPROTO_ICMPV6);

#if LWIP_DNS
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("+PING6:\r\n");
  if (lwip_strnicmp(inet6_ntoa(to.sin6_addr), host_addr, sizeof(to.sin6_addr))) {
    /* If There Was A DNS Resolution */
    (void)hi_at_printf("PING6 %s (%s) with %d bytes of data.\n", host_addr,
                       inet6_ntoa(to.sin6_addr), LWIP_PING6_STANDARD_PKT_SIZE);
  } else {
    (void)hi_at_printf("PING6 %s with %d bytes of data.\n", inet6_ntoa(to.sin6_addr), LWIP_PING6_STANDARD_PKT_SIZE);
  }
#else
  if (lwip_strnicmp(inet6_ntoa(to.sin6_addr), host_addr, sizeof(to.sin6_addr))) {
    /* If There Was A DNS Resolution */
    PRINTK("PING6 %s (%s) with %d bytes of data.\n", host_addr, inet6_ntoa(to.sin6_addr),
           LWIP_PING6_STANDARD_PKT_SIZE);
  } else {
    PRINTK("PING6 %s with %d bytes of data.\n", inet6_ntoa(to.sin6_addr), LWIP_PING6_STANDARD_PKT_SIZE);
  }
#endif
#else
  PRINTK("PING6 %s with %d bytes of data\n", inet6_ntoa(to.sin6_addr), LWIP_PING6_STANDARD_PKT_SIZE);
#endif /* LWIP_DNS */
}

u32_t
osShellPing6(int argc, const char **argv)
{
  int ret;
  void *param = NULL;
  ping6_args_t ping6_params;
  u8_t type;

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  if ((argc < 1) || (argc > LWIP_MAX_PING6_ARG_COUNT) || (argv == NULL)) {
    return LOS_NOK;
  }
  (void)memset_s(&ping6_params, sizeof(ping6_args_t), 0, sizeof(ping6_args_t));
  ret = parse_args_ping6(argc, argv, &ping6_params);
  if (ret == -1) {
    return LOS_NOK;
  } else if (ret == 1) {
    return LOS_OK;
  }

  if ((ping6_params.args_found & LWIP_PING6_SOURCE_ADDRESS_ARG) != 0) {
    type = LWIP_PING6_SOURCE_ADDRESS_ARG;
    param = (void *)(&ping6_params.src_addr);
  } else if ((ping6_params.args_found & LWIP_PING6_INTERFACE_ARG) != 0) {
    type = LWIP_PING6_INTERFACE_ARG;
    param = (void *)(argv[ping6_params.interface_index]);
  } else {
    type = LWIP_PING6_DEFAULT_SOCKET;
    param = NULL;
  }

  ping6_print_data(&ping6_params, argv[ping6_params.host_index]);

#if LWIP_LITEOS_TASK
  u32_t count = ping6_params.pingcount;
  /* start one task if ping count greater than 4 */
  if (count > LWIP_SHELL_CMD_PING6_RETRY_TIMES) {
    return start_ping6_task(&ping6_params, type, param);
  }
#endif
  /*
   * two cases:
   * 1, ping cout less than LWIP_SHELL_CMD_PING_RETRY_TIMES;
   * 2, ping task create failed;
   */
  if ((unsigned int)os_ping_fun6(type, param, ping6_params) != LOS_OK) {
    PRINTK("os_ping_fun6 failed due to some errors\n");
    return LOS_NOK;
  }

  return LOS_OK;
}

LWIP_STATIC int
create_ping6_socket(u8_t type, void *param)
{
  int sfd;
  int ret;
  struct sockaddr_in6 st_host_addr6;
#if LWIP_SOCK_OPT_ICMP6_FILTER
  struct icmp6_filter icmp6_sock_filter;
#endif /* LWIP_SOCK_OPT_ICMP6_FILTER */

  sfd = lwip_socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
  if (sfd == -1) {
    PRINTK("ping6 : Failed, socket creation failed\n");
    return -1;
  }

  if (param != NULL) {
    if (type == LWIP_PING6_SOURCE_ADDRESS_ARG) {
      /* Binding socket to the provided source address */
      (void)memset_s(&st_host_addr6, sizeof(st_host_addr6), 0, sizeof(st_host_addr6));
      st_host_addr6.sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
      (void)memcpy_s((&st_host_addr6.sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                     ((ip6_addr_t *)param)->addr, sizeof(struct ip6_addr));
#else
      inet6_addr_from_ip6addr(&st_host_addr6.sin6_addr, (ip6_addr_t *)param);
#endif
      st_host_addr6.sin6_port = htons(IPPROTO_ICMPV6);
      st_host_addr6.sin6_scope_id = 0;

      ret = lwip_bind(sfd, (struct sockaddr *)&st_host_addr6, (socklen_t)(sizeof(st_host_addr6)));
      if (ret == -1) {
        (void)lwip_close(sfd);
        sfd = -1;
#if CUSTOM_AT_COMMAND
        (void)hi_at_printf("ping6 : bind icmp socket: cannot assign requested address\r\n");
#else
        PRINTK("ping6 : bind icmp socket: cannot assign requested address\n");
#endif
        return ret;
      }
    } else if (type == LWIP_PING6_INTERFACE_ARG) {
      /* Binding socket to the provided netif */
      ret = lwip_setsockopt(sfd, SOL_SOCKET, SO_BINDTODEVICE, (char *)(param), strlen((char *)(param)));
      if (ret == -1) {
        (void)lwip_close(sfd);
        sfd = -1;
        PRINTK("ping6: unknown iface %s\n", (char *)(param));
        return ret;
      }
    }
  }

#if LWIP_SOCK_OPT_ICMP6_FILTER
  /* Setting socket filter since we are interested only in ECHO REPLY and ERROR messages */
  ICMP6_FILTER_SETBLOCKALL(&icmp6_sock_filter);
  ICMP6_FILTER_SETPASS(ICMP6_TYPE_EREP, &icmp6_sock_filter);
  ICMP6_FILTER_SETPASS(ICMP6_TYPE_DUR, &icmp6_sock_filter);
  ICMP6_FILTER_SETPASS(ICMP6_TYPE_PTB, &icmp6_sock_filter);
  ICMP6_FILTER_SETPASS(ICMP6_TYPE_TE, &icmp6_sock_filter);

  ret = lwip_setsockopt(sfd, IPPROTO_ICMPV6, ICMP6_FILTER, &icmp6_sock_filter, sizeof(struct icmp6_filter));
  if (ret == -1) {
    (void)lwip_close(sfd);
    PRINTK("ping6 : setsockopt: Invalid Argument\n");
    return -1;
  }
#endif /* LWIP_SOCK_OPT_ICMP6_FILTER */

  return sfd;
}

static int
ping6_kill_parse(void)
{
  if (ping6_taskid > 0) {
    ping6_kill = 1; /* stop the current ping task */
    return 1;
  } else {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("No ping task running...\n");
#else
    PRINTK("No ping task running...\n");
#endif
    return ERR_OK;
  }
}

static int
ping6_handle_iface_or_src(const ping6_args_t *ping6_params, const int i, const int argc)
{
  /*
   * Handle interface ID / sourceAddress using which the ICMP Packets has to be
   * transmitted :: -I [interface_id/source_address]
   */
  if ((ping6_params->args_found & LWIP_PING6_SOURCE_ADDRESS_ARG) ||
      (ping6_params->args_found & LWIP_PING6_INTERFACE_ARG)) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6: -I option present multiple times \n");
#else
    PRINTK("ping6: -I option present multiple times \n");
#endif
    return -1;
  }

  if (i + 2 > argc) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6: interface/source address(-I) should require an argument \n");
#else
    PRINTK("ping6: interface/source address(-I) should require an argument \n");
#endif
    return -1;
  }
  return 0;
}

static int
ping6_args_check(const ping6_args_t *ping6_params)
{
  if ((ping6_params->args_found & LWIP_PING6_HOSTNAME_ARG) == 0) {
    /* Hostname/IPv6 address not found */
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : Hostname/IPv6 address to ping is not specified or Interface is wrong\n");
#else
    PRINTK("ping6 : Hostname/IPv6 address to ping is not specified\n");
#endif
    return -1;
  }

  if (ip6_addr_islinklocal(&(ping6_params->dst_addr)) &&
      ((ping6_params->args_found & (LWIP_PING6_INTERFACE_ARG | LWIP_PING6_SOURCE_ADDRESS_ARG)) == 0)) {
    /* For link-local addresses, -I is mandatory */
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : Interface specification is mandatory for link-local addresses\n");
#else
    PRINTK("ping6 : Interface specification is mandatory for link-local addresses\n");
#endif
    return -1;
  }
  return 0;
}

static int
ping6_resolve_address(ping6_args_t *ping6_params, const char *hostname)
{
#if LWIP_DNS
    struct addrinfo hints_structure;
    struct addrinfo *res = NULL;
#endif
  int ret;
#if LWIP_DNS
  /* Resolve the given hostname */
  hints_structure.ai_family = AF_INET6;
  hints_structure.ai_flags = 0;
  ret = lwip_getaddrinfo(hostname, NULL, &hints_structure, &res);
  if (ret != ERR_OK) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : Host : %s can't be resolved to IPv6 address\n", hostname);
#else
    PRINTK("ping6 : Host : %s can't be resolved to IPv6 address\n", hostname);
#endif
    ret = -1;
    goto exit;
  }

  inet6_addr_to_ip6addr(&(ping6_params->dst_addr), &(((const struct sockaddr_in6 *)(res->ai_addr))->sin6_addr));
#else
  /* Convert the string representation to network form */
  if (ip6addr_aton(hostname, &(ping6_params->dst_addr)) == 0) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : Invalid IPv6 Address : %s\n", hostname);
#else
    PRINTK("ping6 : Invalid IPv6 Address : %s\n", hostname);
#endif
    ret = -1;
    goto exit;
  }
#endif /* LWIP_DNS */

  if (ip6_addr_isany(&(ping6_params->dst_addr)) || ip6_addr_isnone(&(ping6_params->dst_addr))) {
#if LWIP_DNS
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : IPv6 address of host : %s (%s) is invalid\n", hostname,
                       ip6addr_ntoa((const ip6_addr_t*)&(ping6_params->dst_addr)));
#else
    PRINTK("ping6 : IPv6 address of host : %s (%s) is invalid\n", hostname,
           ip6addr_ntoa((const ip6_addr_t*)(&(ping6_params->dst_addr))));
#endif
#else
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6 : Invalid IPv6 address : %s\n", hostname);
#else
    PRINTK("ping6 : Invalid IPv6 address : %s\n", hostname);
#endif
#endif /* LWIP_DNS */
    ret = -1;
    goto exit;
  }
  ret = 0;
exit:
#if LWIP_DNS
  lwip_freeaddrinfo(res);
  res = NULL;
#endif /* LWIP_DNS */
  return ret;
}

static int
ping6_counts_invalid(const ping6_args_t *ping6_params, int i, int argc)
{
  /* Handle number of ICMP packets to transmit :: -c [number_of_packets] */
  if (ping6_params->args_found & LWIP_PING6_COUNT_ARG) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6: -c option present multiple times \n");
#else
    PRINTK("ping6: -c option present multiple times \n");
#endif
    return -1;
  }

  if (i + 2 > argc) {
#if CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping6: ping count(-c) should require an argument \n");
#else
    PRINTK("ping6: ping count(-c) should require an argument \n");
#endif
    return -1;
  }
  return 0;
}

static void
ping6_params_init(ping6_args_t *ping6_params)
{
  IP6_ADDR(&(ping6_params->dst_addr), 0, 0, 0, 0);
  IP6_ADDR(&(ping6_params->src_addr), 0, 0, 0, 0);

  ping6_params->pingcount  = LWIP_SHELL_CMD_PING_RETRY_TIMES;
  ping6_params->host_index = 0;
  ping6_params->args_found = 0;
}
/*
 * Function to parse the command line args for ping6 shell utility
 * @return:
 *  Success: ERR_OK
 *  Failure: -1
 *  Stop: 1
 */
LWIP_STATIC int
parse_args_ping6(int argc, const char **argv, ping6_args_t *ping6_params)
{
  int ret;
  int pingcount;
  int i = 0;
  ping6_params_init(ping6_params);
  while (i < argc) {
    if (strcmp("-k", argv[i]) == 0) {
      ret = ping6_kill_parse();
      if (ret == 1) {
        return 1;
      } else if (ret == ERR_OK) {
        return ERR_OK;
      }
    } else if (strcmp("-c", argv[i]) == 0) {
      ret = ping6_counts_invalid(ping6_params, i, argc);
      if (ret == -1) {
        goto exit;
      }
      pingcount = atoi(argv[i + 1]);
      if (pingcount <= 0) {
#if CUSTOM_AT_COMMAND
        (void)hi_at_printf("ping6: bad number of packets to transmit \n");
#else
        PRINTK("ping6: bad number of packets to transmit \n");
#endif
        ret = -1;
        goto exit;
      }
      ping6_params->args_found |= LWIP_PING6_COUNT_ARG;
      ping6_params->pingcount = (u32_t)pingcount;
      i = (i + 2);
    } else if (strcmp("-I", argv[i]) == 0) {
      ret = ping6_handle_iface_or_src(ping6_params, i, argc);
      if (ret == -1) {
        goto exit;
      }
      /* Check whether the given argument to -I is source address */
      if (ip6addr_aton(argv[i + 1], &(ping6_params->src_addr))) {
        ping6_params->args_found |= LWIP_PING6_SOURCE_ADDRESS_ARG;
        i = (i + 2);
        continue;
      }
      /* Storing the index where interface name is found */
      /* If this name is not valid, then it will fail later in setsockopt(BIND_TO_DEVICE) */
      ping6_params->interface_index = (u8_t)(i + 1);
      ping6_params->args_found |= LWIP_PING6_INTERFACE_ARG;
      i = (i + 2);
    } else {
      if (argv[i][0] == '-') {
        /* Check whether its a bad option */
#if CUSTOM_AT_COMMAND
        (void)hi_at_printf("ping6: bad option %s\n", argv[i]);
#else
        PRINTK("ping6: bad option %s\n", argv[i]);
#endif
        ret = -1;
        goto exit;
      } else if (ping6_params->args_found & LWIP_PING6_HOSTNAME_ARG) {
        /* Check whether hostname is already found and there are extra arguments */
#if CUSTOM_AT_COMMAND
        (void)hi_at_printf("ping6: bad parameter %s\n", argv[i]);
#else
        PRINTK("ping6: bad parameter %s\n", argv[i]);
#endif
        ret = -1;
        goto exit;
      }
      ret = ping6_resolve_address(ping6_params, argv[i]);
      if (ret == -1) {
        goto exit;
      }

      /* Setting host_index to the index of argv[] where the host/IP is present */
      ping6_params->args_found |= LWIP_PING6_HOSTNAME_ARG;
      ping6_params->host_index = (u8_t)(i);
      i = (i + 1);
    }
  }
  ret = ping6_args_check(ping6_params);
  if (ret == -1) {
    goto exit;
  }
  return ERR_OK;
exit:
#ifndef CUSTOM_AT_COMMAND
  PRINTK("Usage:\n");
  PRINTK("\t ping6 [-c count] [-I interface/sourceAddress] destination\n");
  PRINTK("\t ping6 -k\n");
#endif
  return ret;
}

/*
 * Function to update ping6_stats
 * stats is maintained in ping6_stats structure
 */
LWIP_STATIC void
update_ping6_stats(ping6_stats_t *ping6_stats, u32_t rtt, u32_t nrecieved)
{
  if (rtt > ping6_stats->max_rtt) {
    ping6_stats->max_rtt = rtt;
  }

  if (ping6_stats->flag == 0 || rtt < ping6_stats->min_rtt) {
    ping6_stats->min_rtt = rtt;
    ping6_stats->flag = 1;
  }

  ping6_stats->avg_rtt = (float)(ping6_stats->avg_rtt + (float)((float)((float)rtt - ping6_stats->avg_rtt) /
                                                                (float)(nrecieved)));
}

LWIP_STATIC const char *
convert_icmpv6_err_to_string(u8_t err_type)
{
  switch (err_type) {
    case ICMP6_TYPE_DUR:
      return "Destination Unreachable";
    case ICMP6_TYPE_PTB:
      return "Packet too big";
    case ICMP6_TYPE_TE:
      return "Time Exceeded";
    case ICMP6_TYPE_PP:
      return "Parameter Problem";
    default:
      break;
  }
  return "Unknown Error";
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ping6_shellcmd, CMD_TYPE_EX, "ping6", XARGS, (CmdCallBackFunc)osShellPing6);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_IPV6 */

#if LWIP_ENABLE_MESH_SHELL_CMD
#if LWIP_RIPPLE
#define RPL_INSTANCE_ID 99
#define DEFAULT_NONMESH_INTERFACE  "wlan0"
static void
RplLBRStart(void)
{
  uint8_t ret;
  rpl_addr_t dag_id;
  rpl_prefix_t prefix;
  struct netif *sta_netif = NULL;

  RPL_SET_ADDR(&dag_id, 0xfd00, 0, 0, 0, 0, 0, 0, 0x1000);
  RPL_SET_ADDR(&prefix.addr, 0xfd00, 0, 0, 0, 0, 0, 0, 0x0000);
  prefix.len = 64; /* 64 : ipv6 prefix len */
  prefix.lifetime = 0xffff; /* 0xffff : max ipv6 prefix lifetime */

  sta_netif = netif_find(DEFAULT_NONMESH_INTERFACE);
  if (sta_netif == NULL) {
    PRINTK("no such netif named %s\n", DEFAULT_NONMESH_INTERFACE);
    return;
  }

  ret = rpl_get_slaac_addr(&dag_id, rpl_config_get_lladdr());
  if (ret != RPL_OK) {
    PRINTK("RplGetSlaacAddr fail\n");
    return;
  }
  ret = rpl_mgmt_set_root(RPL_INSTANCE_ID, NULL, &dag_id);
  if (ret != RPL_OK) {
    PRINTK("RplMgmtSetRoot fail\n");
    return;
  }

  ret = rpl_mgmt_set_prefix(RPL_INSTANCE_ID, &prefix);
  if (ret != RPL_OK) {
    PRINTK("RplMgmtSetPrefix fail\n");
    return;
  }

  ret = rpl_mgmt_start(RPL_MODE_6LBR);
  if (ret != RPL_OK) {
    PRINTK("RplMgmtStart fail\n");
    return;
  }

#if LWIP_NAT64
  (void)nat64_init(sta_netif);
  (void)netif_set_default(sta_netif);
#else
  PRINTK("NAT64 stateful is not started, just using mesh\n");
#endif
}

static void
RplLRStart(void)
{
  (void)rpl_mgmt_start(RPL_MODE_6LR);

#if LWIP_NAT64 && defined(LWIP_NAT64_STATELESS)
  (void)nat64_init(NULL);
#else
  PRINTK("NAT64 stateless is not started, just using ipv6 mesh\n");
#endif
}

static void
RplCleanup(void)
{
#if LWIP_NAT64
  (void)nat64_deinit();
#endif
  rpl_mgmt_deinit();
}

static void
rplParentInfo(rpl_parent_t *prnt)
{
  int i;

  if ((prnt == NULL)) {
    return;
  }
  PRINTK("\t\tlocAddr: %s\n", ip6addr_ntoa((const ip6_addr_t *)(&(prnt->loc_addr))));
  PRINTK("\t\tmacAddr: ");
  for (i = 0; i < prnt->mac_addr.len; i++) {
    if (i == 0) {
      PRINTK("%02x", prnt->mac_addr.addr[i]);
    } else {
      PRINTK(":%02x", prnt->mac_addr.addr[i]);
    }
  }
  PRINTK("\n");
  PRINTK("\t\tglobalAddr: %s\n", ip6addr_ntoa((const ip6_addr_t *)(&(prnt->global_addr))));

  PRINTK("\t\tmetric:\n");
  PRINTK("\t\t\ttype: %hhu\n", prnt->mc.type);
  PRINTK("\t\t\tP: %hhu\n", prnt->mc.p);
  PRINTK("\t\t\tC: %hhu\n", prnt->mc.c);
  PRINTK("\t\t\tO: %hhu\n", prnt->mc.o);
  PRINTK("\t\t\tR: %hhu\n", prnt->mc.r);
  PRINTK("\t\t\tA: %hhu\n", prnt->mc.a);
  PRINTK("\t\t\tprec: %hhu\n", prnt->mc.prec);
  PRINTK("\t\t\tobj: %hu\n", prnt->mc.obj.num_hops);

  PRINTK("\t\trank: %hu\n", prnt->rank);
  PRINTK("\t\tlinkMetric: %hu\n", prnt->link_metric);
  PRINTK("\t\tdtsn: %hhu\n", prnt->dtsn);
  PRINTK("\t\tsmRssi: %hhd\n", prnt->sm_rssi);
  PRINTK("\t\tisResFull: %hhu\n", prnt->is_res_full);
  PRINTK("\t\tinuse: %hhu\n", prnt->inuse);
  PRINTK("\t\tisPreferred: %hhu\n", prnt->is_preferred);

  return;
}

static void
prefixListInfo(rpl_prefix_t *list, u8_t list_len)
{
  u8_t i;

  for (i = 0; i < list_len; i++) {
    if (list[i].len == 0) {
      continue;
    }
    PRINTK("\t\t\t%s/%hhu, lifetime %u, autoAddrConf %hhu, isRouterAddr %hhu\n",
           ip6addr_ntoa((const ip6_addr_t *)(&(list[i].addr))), list[i].len, list[i].lifetime,
           list[i].auto_addr_conf, list[i].is_router_addr);
  }

  return;
}

static void
rplInstanceInfo(struct rpl_instance_s *inst)
{
  PRINTK("\tinstID: %"RPL_INST_F"\n", inst->inst_id);
  if (inst->obj_func) {
    PRINTK("\t\tocp: %hu\n", inst->obj_func->ocp);
  }
  PRINTK("\t\tmode: %hhu\n", inst->mode);
  PRINTK("\t\tisroot: %hhu\n", inst->isroot);
  PRINTK("\t\ttarget:\n");
  prefixListInfo(inst->target, RPL_CONF_MAX_TARGETS);
  PRINTK("\t\tprefix:\n");
  prefixListInfo(inst->prefix, RPL_CONF_MAX_PREFIXES);
  PRINTK("\t\tcfg:\n");
  PRINTK("\t\t\trackTimerVal: %u\n", inst->cfg.rack_timer_val);
  PRINTK("\t\t\tlifetimeUnit: %hu\n", inst->cfg.lifetime_unit);
  PRINTK("\t\t\tminRankInc: %hu\n", inst->cfg.min_rank_inc);
  PRINTK("\t\t\tmaxRankInc: %hu\n", inst->cfg.max_rank_inc);
  PRINTK("\t\t\tocp: %hu\n", inst->cfg.ocp);
  PRINTK("\t\t\tlifetime: %hhu\n", inst->cfg.lifetime);
  PRINTK("\t\t\tdioImin: %hhu\n", inst->cfg.dio_imin);
  PRINTK("\t\t\tdioRed: %hhu\n", inst->cfg.dio_red);
  PRINTK("\t\t\tdioIdbl: %hhu\n", inst->cfg.dio_idbl);
  PRINTK("\t\t\tmop: %hhu\n", inst->cfg.mop);
  PRINTK("\t\t\trackRetry: %hhu\n", inst->cfg.rack_retry);

  return;
}

static void
rplDagInfo(rpl_dag_t *dag)
{
  int         state = 0;
  rpl_parent_t *prnt = NULL;

  if (dag == NULL) {
    return;
  }
  if (dag->inst != NULL) {
    rplInstanceInfo(dag->inst);
  }
  PRINTK("\tdodagID: %s\n", ip6addr_ntoa((const ip6_addr_t *)(&(dag->dodag_id))));
  PRINTK("\tmnid: %hhu\n", dag->mnid);
  PRINTK("\tdaoSeq: %hhu\n", dag->dao_seq);
  PRINTK("\tlastJoinStatus: %hhu\n", dag->last_join_status);
  PRINTK("\tcurDaoState: %hhu\n", dag->cur_dao_state);
  PRINTK("\tdaoRetryCnt: %hhu\n", dag->dao_retry_cnt);
  PRINTK("\trank: %hu\n", dag->rank);
  PRINTK("\tdodagVerNum: %hhu\n", dag->dodag_ver_num);
  PRINTK("\tdtsnOut: %hhu\n", dag->dtsn_out);
  PRINTK("\tpreference: %hhu\n", dag->preference);
  PRINTK("\tpathSeq: %hhu\n", dag->path_seq);
  PRINTK("\tgrounded: %hhu\n", dag->grounded);
  PRINTK("\tmetricUpdated: %hhu\n", dag->metric_updated);
  PRINTK("\tparent:\n");
  while ((prnt = rpl_get_next_parent(dag, &state))) {
    PRINTK("\t\t[%d]:\n", state - 1);
    rplParentInfo(prnt);
  }
  return;
}

static void
rplDagsInfo(void)
{
  rpl_dag_t *dag = NULL;
  int state = 0;
  u8_t i, j;

  PRINTK("[%s][%d] start\n", __FUNCTION__, __LINE__);
  while ((dag = rpl_get_next_inuse_dag(&state))) {
    i = (uint8_t)((u32_t)state & 0x0000ffff);
    j = (uint8_t)(((u32_t)state & 0x7fff0000) >> 16);
    PRINTK("[%hhu][%hhu]:\n", i, (u8_t)(j - 1));
    rplDagInfo(dag);
  }
  PRINTK("[%s][%d] end\n", __FUNCTION__, __LINE__);

  return;
}

static void
os_shell_rpl_internal(void *arg)
{
  struct netif *netif_p = NULL;
  int node_br;
  shell_cmd_t *rpl_cmd = (shell_cmd_t *)arg;
  int argc = rpl_cmd->argc;
  char **argv = rpl_cmd->argv;

  if ((argc == 3) && (strcmp(argv[1], "start") == 0)) {
    netif_p = netif_find(argv[0]);
    if (netif_p == NULL) {
      PRINTK("no such netif named %s\n", argv[0]);
      goto usage;
    }
    node_br = !!atoi(argv[2]);
    if (RPL_OK != rpl_mgmt_init((rpl_netdev_t *)netif_p)) {
      PRINTK("RplMgmtInit fail\n");
      sys_sem_signal(&rpl_cmd->cb_completed);
      return;
    }

    if (node_br) {
      RplLBRStart();
    } else {
      RplLRStart();
      (void)netif_set_default(netif_p);
    }
    netif_p->flags |= NETIF_IS_RPL_UP;
  } else if ((argc == 2) && (strcmp(argv[1], "stop") == 0)) {
    netif_p = netif_find(argv[0]);
    if (netif_p == NULL) {
      goto usage;
    }
    RplCleanup();
    netif_p->flags &= (~NETIF_IS_RPL_UP);
  } else if ((argc == 1) && (strcmp(argv[0], "dag") == 0)) {
    rplDagsInfo();
  } else {
    goto usage;
  }

  sys_sem_signal(&rpl_cmd->cb_completed);
  return;
usage:
  PRINTK("rpl\n\tifname start isBr\n\tifname stop\n\tdag\tprint dags information\n");
  sys_sem_signal(&rpl_cmd->cb_completed);
  return;
}

u32_t
osShellRpl(int argc, char **argv)
{
  shell_cmd_t rpl_cmd = {0};
  err_t ret;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (sys_sem_new(&rpl_cmd.cb_completed, 0) != ERR_OK) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s: sys_sem_new fail\n", __FUNCTION__);
#else
    PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
#endif
    return LOS_NOK;
  }

  rpl_cmd.argc = argc;
  rpl_cmd.argv = argv;

  ret = tcpip_callback(os_shell_rpl_internal, &rpl_cmd);
  if (ret != ERR_OK) {
    sys_sem_free(&rpl_cmd.cb_completed);
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("rpl : internal error, ret:%d\n", ret);
#else
    PRINTK("rpl : internal error, ret:%d\n", ret);
#endif
    return LOS_NOK;
  }
  (void)sys_arch_sem_wait(&rpl_cmd.cb_completed, 0);
  sys_sem_free(&rpl_cmd.cb_completed);

  return LOS_OK;
}
#endif

#if LWIP_RPL
#define DEFAULT_INTERFACE_NAME  "wlan0"
#define DEFAULT_RPL_INSTANCE_ID (99)
#define DEFAULT_IPV6_IID_LEN  (64)

static struct netif *
find_rpl_netif(char *iface)
{
  struct netif *nif = NULL;
  if (iface[0] == '\0') {
    if (strncpy_s(iface, IFNAMSIZ, DEFAULT_INTERFACE_NAME, (strlen(DEFAULT_INTERFACE_NAME))) == EOK) {
      iface[IFNAMSIZ - 1] = '\0';
    } else {
      return NULL;
    }
  }
  nif = netif_find(iface);
  if (nif == NULL) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("netif %s is not exist.\n", iface);
#else
    PRINTK("netif %s is not exist.\n", iface);
#endif
    return NULL;
  } else {
    return nif;
  }
}

static int
start_rpl_network(struct netif *nif, const int is_node_br)
{
  VpprplWSNParametersS wsnparams;
  (void)memset_s(&wsnparams, sizeof(wsnparams), 0, sizeof(wsnparams));

  if (is_node_br == 1) {
    wsnparams.nodeType = VPPRPL_NODE_TYPE_BR;
    wsnparams.instance_id = DEFAULT_RPL_INSTANCE_ID;
    wsnparams.wsnPrefixLen = DEFAULT_IPV6_IID_LEN;
    vpprpl_ip6addr(&wsnparams.wsnPrefix, 0xfd00, 0, 0, 0, 0, 0, 0, 0);
    vpprpl_ip6addr(&wsnparams.dodagID, 0, 0, 0, 0, 0, 0, 0, 0);
  } else {
    wsnparams.nodeType = VPPRPL_NODE_TYPE_NON_BR;
  }

  ret = vpprpl_iface_start_rplnetwork(&wsnparams, (iface_t)nif);
  if (ret != VPPRPL_SUCCESS) {
    PRINTK("vpprpl_iface_start_rplnetwork Failed!\n");
    return LOS_NOK;
  }
  return LOS_OK;
}

u32_t
osShellRpl(int argc, char **argv)
{
  uint8_t ret;
  char iface[IFNAMSIZ] = {0};
  int is_node_br = 0;
  struct netif *nif = NULL;
  int i = 0;
  int j = argc;

  if (argc < 1) {
    goto usage;
  }

  while (j > 0) {
    if (strcmp(argv[i], "-b") == 0) {
      is_node_br = 1;
      i++;
      j--;
    } else if (strcmp(argv[i], "-I") == 0) {
      if (strlen(argv[i + 1]) < IFNAMSIZ) {
        (void)strncpy_s(iface, IFNAMSIZ, argv[i + 1], (strlen(argv[i + 1])));
        iface[IFNAMSIZ - 1] = '\0';
      }

      i += 2; /* 2: skip two argv index */
      j -= 2; /* 2: skip already check two parameter */
    } else {
      goto usage;
    }
  }

  nif = find_rpl_netif(iface);
  if (nif == NULL) {
    return LOS_NOK;
  }

  ret = start_rpl_network(nif, is_node_br);
  if (ret == LOS_NOK) {
    return LOS_NOK;
  }

#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("rpl %s started!\n", is_node_br ? "MBR" : "MG");
#else
  PRINTK("rpl %s started!\n", is_node_br ? "MBR" : "MG");
#endif
  return LOS_OK;

usage:
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("\nUsage:\n");
    (void)hi_at_printf("rpl [-b] [-I interface] ...\n");
#else
  PRINTK("\nUsage:\n");
  PRINTK("rpl [-b] [-I interface] ...\n");
#endif
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(rpl_shellcmd, CMD_TYPE_EX, "rpl", XARGS, (CmdCallBackFunc)osShellRpl);
#endif /* LOSCFG_SHELL */

#endif /* LWIP_RPL */

#define MCAST6_TEST_PORT (5000)
#define MCAST6_TEST_TASK_NAME "mcast6"
#define MCAST6_TEST_TASK_PRIORITY 25
#define MCAST6_TEST_TASK_STACK 4096
#define MCAST6_RECV_BUF_LEN (128)
#define MCAST6_TASK_DELAY (200) // ms
#define MCAST6_TASK_STOP_DELAY (1000) // ms

static int g_ser_fd = -1;
static int g_cli_fd = -1;
static u8_t g_mcast6_cli_task_finish = lwIP_FALSE;
static u8_t g_mcast6_ser_ip_type = IPADDR_TYPE_V6;

static void
os_shell_mcast6_usage(void)
{
  PRINTK("mcast6\n\tser {start srcAddr | stop}\n\tser send destAddr message\n"
         "\tcli {start | stop}\n\ttable show\n"
#if LWIP_DHCP_COAP_RELAY
         "\tcoap {mg ifname | mbr dhcpServAddr coapIf dhcpIf}\n"
#endif
         "\tesmrf {init | deinit}\n");
}

static int
mcast6_ser_socket_op(struct sockaddr *sockaddr, const socklen_t addr_len)
{
  int opt, ret;
  opt = lwIP_TRUE;
  ret = setsockopt(g_ser_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
  if (ret != ERR_OK) {
    PRINTK("setsockopt fail\n");
    return -1;
  }

  ret = setsockopt(g_ser_fd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));
  if (ret != ERR_OK) {
    PRINTK("setsockopt bcast fail\n");
    return -1;
  }

  ret = bind(g_ser_fd, sockaddr, addr_len);
  if (ret != ERR_OK) {
    PRINTK("bind src_addr fail\n");
    return -1;
  }
  return 0;
}

static err_t
mcast6_ser_start(char *src_addr)
{
  int ret;
  int domain;
  struct sockaddr_in6 addr6 = {0};
  struct sockaddr_in addr = {0};
  struct sockaddr *sockaddr = NULL;
  socklen_t addr_len;
  ip_addr_t sip = {0};

  if (g_ser_fd >= 0) {
    PRINTK("ser have started\n");
    return ERR_OK;
  }

  if (ipaddr_aton(src_addr, &sip) == 0) {
    PRINTK("invalid ip6 addr\n");
    return ERR_ARG;
  }

  if (sip.type == IPADDR_TYPE_V6) {
    domain = AF_INET6;
    addr6.sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
    (void)memcpy_s((&addr6.sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                   (&sip.u_addr.ip6)->addr, sizeof(struct ip6_addr));
#else
    inet6_addr_from_ip6addr(&addr6.sin6_addr, &sip.u_addr.ip6);
#endif
    addr6.sin6_port = 0;
    addr6.sin6_scope_id = 0;
    sockaddr = (struct sockaddr *)&addr6;
    addr_len = sizeof(addr6);
    g_mcast6_ser_ip_type = IPADDR_TYPE_V6;
  } else {
    domain = AF_INET;
    addr.sin_family = AF_INET;
    addr.sin_port = 0;
    addr.sin_addr.s_addr = sip.u_addr.ip4.addr;
    sockaddr = (struct sockaddr *)&addr;
    addr_len = sizeof(addr);
    g_mcast6_ser_ip_type = IPADDR_TYPE_V4;
  }

  g_ser_fd = socket(domain, SOCK_DGRAM, IPPROTO_UDP);
  if (g_ser_fd < 0) {
    PRINTK("socket fail\n");
    return -1;
  }

  ret = mcast6_ser_socket_op(sockaddr, addr_len);
  if (ret == -1) {
    goto failure;
  }

  return ERR_OK;
failure:
  (void)closesocket(g_ser_fd);
  g_ser_fd = -1;
  return -1;
}

static err_t
mcast6_ser_stop(void)
{
  if (g_ser_fd >= 0) {
    (void)closesocket(g_ser_fd);
    g_ser_fd = -1;
  }
  PRINTK("stop success\n");

  return ERR_OK;
}

static err_t
mcast6_ser_send(char *groupaddr, char *msg)
{
  struct sockaddr_in addr;
  struct sockaddr_in6 addr6 = {0};
  struct sockaddr *to = NULL;
  socklen_t tolen;
  ip_addr_t dip = {0};
  ssize_t actual_send;

  if (g_ser_fd < 0) {
    PRINTK("ser not started\n");
    return ERR_VAL;
  }

  if (ipaddr_aton(groupaddr, &dip) == 0) {
    PRINTK("invalid groupaddr %s\n", groupaddr);
    return ERR_ARG;
  }
  if (dip.type != g_mcast6_ser_ip_type) {
    PRINTK("invalid ip ver\n");
    return ERR_ARG;
  }
  if (g_mcast6_ser_ip_type == IPADDR_TYPE_V6) {
    if (!ip6_addr_ismulticast(&dip.u_addr.ip6)) {
      PRINTK("not mcast6 addr\n");
      return ERR_ARG;
    }
    addr6.sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
    (void)memcpy_s((&addr6.sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                   (&dip.u_addr.ip6)->addr, sizeof(struct ip6_addr));
#else
    inet6_addr_from_ip6addr(&addr6.sin6_addr, &dip.u_addr.ip6);
#endif
    addr6.sin6_port = htons(MCAST6_TEST_PORT);
    to = (struct sockaddr *)&addr6;
    tolen = sizeof(addr6);
  } else {
    addr.sin_family = AF_INET;
    addr.sin_port = htons(MCAST6_TEST_PORT);
    addr.sin_addr.s_addr = dip.u_addr.ip4.addr;
    to = (struct sockaddr *)&addr;
    tolen = sizeof(addr);
  }
  PRINTK("send %s to %s\n", msg, ipaddr_ntoa(&dip));

  actual_send = sendto(g_ser_fd, msg, strlen(msg), 0, to, tolen);
  PRINTK("[%zu] actual_send %zd\n", strlen(msg), actual_send);
  if (actual_send < 0) {
    (void)closesocket(g_ser_fd);
    g_ser_fd = -1;
    PRINTK("udp abort\n");
    return ERR_NETUNREACH;
  }

  return ERR_OK;
}

static err_t
mcast6_ser_ctrl(int argc, char **argv)
{
  err_t ret;

  if ((argc == 3) && (strcmp(argv[1], "start") == 0)) {
    ret = mcast6_ser_start(argv[2]);
  } else if (strcmp(argv[1], "stop") == 0) {
    ret = mcast6_ser_stop();
  } else if ((argc == 4) && (strcmp(argv[1], "send") == 0)) {
    ret = mcast6_ser_send(argv[2], argv[3]);
  } else {
    goto failure;
  }

  return ret;

failure:
  os_shell_mcast6_usage();
  return ERR_ARG;
}

static int
mcast_cli_task_socket_op(void)
{
  int opt;
  int ret;
  g_cli_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
  if (g_cli_fd < 0) {
    PRINTK("socket fail\n");
    return -1;
  }

  opt = lwIP_TRUE;
  ret = setsockopt(g_cli_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
  if (ret != ERR_OK) {
    PRINTK("setsockopt reuse fail\n");
    return -1;
  }

  ret = setsockopt(g_cli_fd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));
  if (ret != ERR_OK) {
    PRINTK("setsockopt bcast fail\n");
    return -1;
  }
  return 0;
}

static err_t
mcast6_cli_task_start(void)
{
  int ret, actual_recv;
  struct sockaddr *sockaddr = NULL;
  socklen_t addr_len;
  struct sockaddr_in6 addr6 = {0};
  char buffer[MCAST6_RECV_BUF_LEN] = {0};

  ret = mcast_cli_task_socket_op();
  if (ret == -1) {
    goto failure;
  }

  addr6.sin6_family = AF_INET6;
#if LWIP_LITEOS_COMPAT
  (void)memcpy_s((&addr6.sin6_addr)->s6_addr, sizeof(struct ip6_addr),
                 (&(IP6_ADDR_ANY->u_addr.ip6))->addr, sizeof(struct ip6_addr));
#else
  inet6_addr_from_ip6addr(&addr6.sin6_addr, &(IP6_ADDR_ANY->u_addr.ip6));
#endif
  addr6.sin6_port = htons(MCAST6_TEST_PORT);
  sockaddr = (struct sockaddr *)&addr6;
  addr_len = sizeof(addr6);

  if (bind(g_cli_fd, sockaddr, addr_len) != 0) {
    PRINTK("bind fail\n");
    goto failure;
  }

  PRINTK("mcast6 start to recv\n");
  while (g_mcast6_cli_task_finish == lwIP_FALSE) {
    actual_recv = recvfrom(g_cli_fd, buffer, MCAST6_RECV_BUF_LEN, 0, sockaddr, &addr_len);
    if (actual_recv < 0) {
      PRINTK("recvfrom failed\n");
      break;
    } else {
      PRINTK("[Mcast6CliRecv]recv len : %d, data : %.*s, from %s:%hu\n", actual_recv, actual_recv, buffer,
             ip6addr_ntoa((const ip6_addr_t *)(&addr6.sin6_addr)), ntohs(addr6.sin6_port));
#if (LWIP_LITEOS_COMPAT == 0)
      fflush(NULL);
#endif
    }
    sys_msleep(MCAST6_TASK_DELAY);
  }

  g_mcast6_cli_task_finish = lwIP_FALSE;
  (void)closesocket(g_cli_fd);
  g_cli_fd = -1;
  PRINTK("task exit\n");
  return 0;
failure:
  if (g_cli_fd >= 0) {
    (void)closesocket(g_cli_fd);
    g_cli_fd = -1;
  }
  return -1;
}

static err_t
mcast6_cli_stop(void)
{
  if (g_cli_fd < 0) {
    PRINTK("ser have stopped\n");
    return LOS_OK;
  }
  g_mcast6_cli_task_finish = lwIP_TRUE;
  (void)closesocket(g_cli_fd);
  g_cli_fd = -1;
  PRINTK("wait task to stop\n");
  sys_msleep(MCAST6_TASK_STOP_DELAY);
  PRINTK("task stop success\n");

  return LOS_OK;
}

static err_t
mcast6_cli_start(void)
{
  u32_t ret;

  if (g_cli_fd >= 0) {
    PRINTK("mcast6 cli is running\n");
    return LOS_OK;
  }

  ret = sys_thread_new(MCAST6_TEST_TASK_NAME, (lwip_thread_fn)mcast6_cli_task_start, NULL, MCAST6_TEST_TASK_STACK,
                       MCAST6_TEST_TASK_PRIORITY);
  if (ret == SYS_ARCH_ERROR) {
    PRINTK("create task %s failed", MCAST6_TEST_TASK_NAME);
    return LOS_NOK;
  }

  return LOS_OK;
}

static err_t
mcast6_cli_ctrl(char **argv)
{
  err_t ret;

  if (strcmp(argv[1], "start") == 0) {
    ret = mcast6_cli_start();
  } else if (strcmp(argv[1], "stop") == 0) {
    ret = mcast6_cli_stop();
  } else {
    goto failure;
  }

  return ret;

failure:
  os_shell_mcast6_usage();
  return ERR_ARG;
}

#if LWIP_MPL
static void
mcast6_table_print(void *argv)
{
  sys_sem_t *cb_completed = (sys_sem_t *)argv;
  mcast6_table_t *list = mcast6_get_table_list();

  PRINTK("%-50s%-16s\n", "mcastAddr", "lifetime");
  while (list != NULL) {
    PRINTK("%-50s%-16u\n", ip6addr_ntoa((const ip6_addr_t *)(&(list->addr))), list->lifetime);
    list = list->next;
  }

  sys_sem_signal(cb_completed);
  return;
}

static err_t
mcast6_table_ctrl(void)
{
  sys_sem_t cb_completed;
  err_t ret;

  if (sys_sem_new(&cb_completed, 0) != ERR_OK) {
    PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
    return LOS_NOK;
  }

  ret = tcpip_callback(mcast6_table_print, &cb_completed);
  if (ret != ERR_OK) {
    sys_sem_free(&cb_completed);
    PRINTK("l2test : internal error, ret:%d\n", ret);
    return LOS_NOK;
  }
  (void)sys_arch_sem_wait(&cb_completed, 0);
  sys_sem_free(&cb_completed);

  return ERR_OK;
}
#else
static err_t
mcast6_table_ctrl(void)
{
  return ERR_VAL;
}
#endif /* LWIP_MPL */

static err_t
mcast6_coap_mg_ctrl(char **argv)
{
#if LWIP_DHCP_COAP_RELAY
  struct netif *netif = NULL;

  netif = netif_find(argv[2]);
  if (netif == NULL) {
    PRINTK("no netif named %s\n", argv[2]);
    return ERR_VAL;
  }

  return dhcp_relay_fake_server_start(netif, netif);
#else
  (void)argv;
  return ERR_VAL;
#endif
}

static err_t
mcast6_coap_mbr_ctrl(char **argv)
{
#if LWIP_DHCP_COAP_RELAY
  ip_addr_t dhcps_ip_addr = IPADDR4_INIT(0);
  struct netif *netif_dhcp = NULL;
  struct netif *netif_coap = NULL;

  if (ip4addr_aton((const char *)(argv[2]), ip_2_ip4(&(dhcps_ip_addr))) == 0) {
    PRINTK("invalid ip4addr %s\n", argv[2]);
    return ERR_VAL;
  }

  netif_coap = netif_find(argv[3]);
  if (netif_coap == NULL) {
    PRINTK("no netif named %s\n", argv[3]);
    return ERR_VAL;
  }

  netif_dhcp = netif_find(argv[4]);
  if (netif_dhcp == NULL) {
    PRINTK("no netif named %s\n", argv[4]);
    return ERR_VAL;
  }

  return dhcp_relay_fake_client_start(dhcps_ip_addr, netif_dhcp, netif_coap);
#else
  (void)argv;
  return ERR_VAL;
#endif
}

static err_t
mcast6_coap_ctrl(int argc, char **argv)
{
  err_t ret;

  if ((strcmp(argv[1], "mg") == 0) && (argc == 3)) {
    ret = mcast6_coap_mg_ctrl(argv);
  } else if ((strcmp(argv[1], "mbr") == 0) && (argc == 5)) {
    ret = mcast6_coap_mbr_ctrl(argv);
  } else {
    goto failure;
  }

  return ret;

failure:
  os_shell_mcast6_usage();
  return ERR_ARG;
}

static err_t
mcast6_esmrf_ctrl(int argc, char **argv)
{
#if LWIP_MPL
  err_t ret;

  if ((strcmp(argv[1], "init") == 0) && (argc == 2)) {
    ret = mcast6_init();
  } else if ((strcmp(argv[1], "deinit") == 0) && (argc == 2)) {
    mcast6_deinit();
    ret = 0;
  } else {
    goto failure;
  }

  return ret;

failure:
  os_shell_mcast6_usage();
  return ERR_ARG;
#else
  (void)argc;
  (void)argv;
  return ERR_ARG;
#endif
}

u32_t
os_shell_mcast6(int argc, char **argv)
{
  int ret = -1;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (argc < 2) { /* 2 : min argc num */
    goto failure;
  }
  if (strcmp(argv[0], "ser") == 0) {
    ret = mcast6_ser_ctrl(argc, argv);
  } else if (strcmp(argv[0], "cli") == 0) {
    ret = mcast6_cli_ctrl(argv);
  } else if ((strcmp(argv[0], "table") == 0) && (strcmp(argv[1], "show") == 0)) {
    ret = mcast6_table_ctrl();
  } else if (strcmp(argv[0], "coap") == 0) {
    ret = mcast6_coap_ctrl(argc, argv);
  } else if (strcmp(argv[0], "esmrf") == 0) {
    ret = mcast6_esmrf_ctrl(argc, argv);
  } else {
    goto failure;
  }
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("mcast6 ret %d\n", ret);
#else
  PRINTK("mcast6 ret %d\n", ret);
#endif
  return ((ret == LOS_OK) ? LOS_OK : LOS_NOK);

failure:
  os_shell_mcast6_usage();
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(mcast6_shellcmd, CMD_TYPE_EX, "mcast6", XARGS, (CmdCallBackFunc)os_shell_mcast6);
#endif /* LOSCFG_SHELL */

#if (LWIP_IPV6 && (LWIP_IPV6_MLD || LWIP_IPV6_MLD_QUERIER))
static void
os_shell_mld6_usage(void)
{
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("mld6\n\tshow\n\tifname {report | stop}\n\tifname {join | leave} groupaddr\n\tifname querier \
      {start | stop | show}\n");
#else
  PRINTK("mld6\n\tshow\n\tifname {report | stop}\n\tifname {join | leave} groupaddr\n\tifname querier \
      {start | stop | show}\n");
#endif
}

static void
mld6_netif_show(void)
{
  struct netif *netif_p = NULL;
  struct mld_group *group = NULL;

#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("\t%-50s%-16s%-16s%-16s%-16s\n", "groupaddr", "reporter", "state", "timer(100ms)", "use");
#else
  PRINTK("\t%-50s%-16s%-16s%-16s%-16s\n", "groupaddr", "reporter", "state", "timer(100ms)", "use");
#endif
  for (netif_p = netif_list; netif_p != NULL; netif_p = netif_p->next) {
    if ((netif_p->flags & NETIF_FLAG_MLD6) == 0) {
      continue;
    }
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s%d\n", netif_p->name, netif_p->num);
#else
    PRINTK("%s%d\n", netif_p->name, netif_p->num);
#endif
    group = netif_mld6_data(netif_p);
    if (group == NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("\n");
#else
      PRINTK("\n");
#endif
      continue;
    }
    while (group != NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("\t%-50s%-16d%-16d%-16d%-16d\n", ip6addr_ntoa(&(group->group_address)),
                         group->last_reporter_flag, group->group_state,
                         group->timer, group->use);
#else
      PRINTK("\t%-50s%-16d%-16d%-16d%-16d\n", ip6addr_ntoa(&(group->group_address)),
             group->last_reporter_flag, group->group_state,
             group->timer, group->use);
#endif
      group = group->next;
    }
  }
}

static s32_t
mld6_netif_ctrl(char **argv)
{
  s32_t ret = 0;
  struct netif *netif_p = NULL;

  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    PRINTK("no such netif named %s\n", argv[0]);
    goto usage;
  }
  if (strcmp(argv[1], "stop") == 0) {
    ret = mld6_stop(netif_p);
  } else if (strcmp(argv[1], "report") == 0) {
    mld6_report_groups(netif_p);
  } else {
    goto usage;
  }

  return ret;
usage:
  os_shell_mld6_usage();
  return -1;
}

static s32_t
mld6_membership_ctrl(char **argv)
{
  s32_t ret = 0;
  struct netif *netif_p = NULL;
  ip6_addr_t groupaddr = {0};

  if (!ip6addr_aton(argv[2], &(groupaddr))) {
    PRINTK("Invalid IPv6 Address : %s\n", argv[2]);
    goto usage;
  }

  if (ip6_addr_isany_val(groupaddr) || ip6_addr_isnone_val(groupaddr) || !(ip6_addr_ismulticast(&groupaddr))) {
    PRINTK("invalid groupaddr %s\n", argv[2]);
    goto usage;
  }
  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    PRINTK("no such netif named %s\n", argv[0]);
    goto usage;
  }
  if (strcmp(argv[1], "join") == 0) {
    ret = mld6_joingroup_netif(netif_p, &groupaddr);
  } else if (strcmp(argv[1], "leave") == 0) {
    ret = mld6_leavegroup_netif(netif_p, &groupaddr);
  } else {
    goto usage;
  }

  return ret;
usage:
  os_shell_mld6_usage();
  return -1;
}

#if LWIP_IPV6_MLD_QUERIER
static void
mld6_querier_status_show(struct mld6_querier *querier)
{
  struct mld6_listener *listener = NULL;

#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("\t%-16s%-16s%-16s\n", "state", "count", "timer");
  (void)hi_at_printf("\t%-16hhu%-16hhu%-16hu\n", querier->querier_state, querier->query_count, querier->timer);
  (void)hi_at_printf("listeners:\n");
#else
  PRINTK("\t%-16s%-16s%-16s\n", "state", "count", "timer");
  PRINTK("\t%-16hhu%-16hhu%-16hu\n", querier->querier_state, querier->query_count, querier->timer);
  PRINTK("listeners:\n");
#endif

  if (querier->listeners != NULL) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("\t%-50s%-16s%-16s%-16s%-16s\n", "addr", "state", "count", "timer", "rexmt_timer");
#else
    PRINTK("\t%-50s%-16s%-16s%-16s%-16s\n", "addr", "state", "count", "timer", "rexmt_timer");
#endif
    listener = querier->listeners;
    do {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("\t%-50s%-16hhu%-16hhu%-16hu%-16hu\n", ip6addr_ntoa(&(listener->group_address)),
                         listener->state, listener->query_count, listener->timer, listener->rexmt_timer);
#else
      PRINTK("\t%-50s%-16hhu%-16hhu%-16hu%-16hu\n", ip6addr_ntoa(&(listener->group_address)),
             listener->state, listener->query_count, listener->timer, listener->rexmt_timer);
#endif
      listener = listener->next;
    } while (listener != NULL);
  }

  return;
}
#endif /* LWIP_IPV6_MLD_QUERIER */

static s32_t
mld6_querier_ctrl(char **argv)
{
#if LWIP_IPV6_MLD_QUERIER
  s32_t ret = 0;
  struct netif *netif_p = NULL;
  struct mld6_querier *querier = NULL;

  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    PRINTK("no such netif named %s\n", argv[0]);
    goto usage;
  }
  if (strcmp(argv[2], "start") == 0) {
    ret = mld6_querier_start(netif_p);
  } else if (strcmp(argv[2], "stop") == 0) {
    mld6_querier_stop(netif_p);
  } else if (strcmp(argv[2], "show") == 0) {
    querier = netif_mld6_querier_data(netif_p);
    if (querier == NULL) {
      PRINTK("mld6 querier not start\n");
    } else {
      mld6_querier_status_show(querier);
    }
  } else {
    goto usage;
  }

  return ret;
usage:
  os_shell_mld6_usage();
  return -1;
#else
  (void)argv;
  PRINTK("mld6 querier not support\n");
  return -1;
#endif /* LWIP_IPV6_MLD_QUERIER */
}

u32_t
os_shell_mld6(int argc, char **argv)
{
  s32_t ret = 0;

  if (tcpip_init_finish == 0) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s: tcpip_init have not been called\n", __FUNCTION__);
#else
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
#endif
    return LOS_NOK;
  }
  if (argv == NULL) {
    return LOS_NOK;
  }
  if ((argc == 1) && (strcmp(argv[0], "show") == 0)) {
    mld6_netif_show();
  } else if (argc == 2) { /* 2 : argc index */
    ret = mld6_netif_ctrl(argv);
  } else if (argc == 3) { /* 3 : argc index */
    if (strcmp(argv[1], "querier") == 0) {
      ret = mld6_querier_ctrl(argv);
    } else {
      ret = mld6_membership_ctrl(argv);
    }
  } else {
    os_shell_mld6_usage();
  }
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("mld6 ret %d\n", ret);
#else
  PRINTK("mld6 ret %d\n", ret);
#endif
  return LOS_OK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(mld6_shellcmd, CMD_TYPE_EX, "mld6", XARGS, (CmdCallBackFunc)os_shell_mld6);
#endif /* LOSCFG_SHELL */
#endif /* (LWIP_IPV6 && (LWIP_IPV6_MLD || LWIP_IPV6_MLD_QUERIER)) */

#if LWIP_RIPPLE & RPL_CONF_IP6
u32_t
osRteDebug(int argc, char **argv)
{
  s32_t state = 0;
  rpl_addr_t tgt;
  rpl_addr_t nhop;
  rpl_mnode_id_t mnid;
  u16_t lt;
  s32_t cnt = 0;
  ip6_addr_t ipv6_addr;
  char ac_ipv6_addr[IP6ADDR_STRLEN_MAX + 1] = {0};
  char *tmp = NULL;
  (void)argc;
  (void)argv;
  if (tcpip_init_finish == 0) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s: tcpip_init have not been called\n", __FUNCTION__);
#else
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
#endif
    goto exit;
  }
  LOCK_TCPIP_CORE();
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("%s, %s, %s, %s, %s\n", "Idx", "RplAddrS", "Nhop", "MNID", "Ltime");
#else
  LWIP_PLATFORM_PRINT("%s, %s, %s, %s, %s\n", "Idx", "RplAddrS", "Nhop", "MNID", "Ltime");
#endif
  while (rpl_platform_get_next_rte(&state, &tgt, &nhop, &lt, &mnid) == RPL_OK) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%d,", ++cnt);
#else
    LWIP_PLATFORM_PRINT("%d,", ++cnt);
#endif
    if (memcpy_s(ipv6_addr.addr, sizeof(ipv6_addr.addr), tgt.a8, sizeof(tgt.a8)) != EOK) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("rtedebug memcpy_s fail\n");
#else
      LWIP_PLATFORM_PRINT("rtedebug memcpy_s fail\n");
#endif
      goto exit;
    }
    tmp = ip6addr_ntoa_r((const ip6_addr_t *)ipv6_addr.addr, ac_ipv6_addr, INET6_ADDRSTRLEN);
    if (tmp == NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("rtedebug ip6addr_ntoa_r is null\n");
#else
      LWIP_PLATFORM_PRINT("rtedebug ip6addr_ntoa_r is null\n");
#endif
      goto exit;
    } else {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("%s,", ac_ipv6_addr);
#else
      LWIP_PLATFORM_PRINT("%s,", ac_ipv6_addr);
#endif
    }
    if (memcpy_s(ipv6_addr.addr, sizeof(ipv6_addr.addr), nhop.a8, sizeof(nhop.a8)) != EOK) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("rtedebug memcpy_s fail\n");
#else
      LWIP_PLATFORM_PRINT("rtedebug memcpy_s fail\n");
#endif
      goto exit;
    }
    tmp = ip6addr_ntoa_r((const ip6_addr_t *)ipv6_addr.addr, ac_ipv6_addr, INET6_ADDRSTRLEN);
    if (tmp == NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("rtedebug ip6addr_ntoa_r is null\n");
#else
      LWIP_PLATFORM_PRINT("rtedebug ip6addr_ntoa_r is null\n");
#endif
      goto exit;
    } else {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("%s,", ac_ipv6_addr);
#else
      LWIP_PLATFORM_PRINT("%s,", ac_ipv6_addr);
#endif
    }
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%u,", mnid);
    (void)hi_at_printf("%u\n", lt);
#else
    LWIP_PLATFORM_PRINT("%u,", mnid);
    LWIP_PLATFORM_PRINT("%u\n", lt);
#endif
  }
  UNLOCK_TCPIP_CORE();
exit:
  return LOS_OK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(rte_shellcmd, CMD_TYPE_EX, "rtedebug", XARGS, (CmdCallBackFunc)osRteDebug);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_RIPPLE & RPL_CONF_IP6 */

#if LWIP_RIPPLE
#define L2_TEST_PORT (12345)
#define BYTE_IN_HEX_LEN (2)
#define L2_PBUF_MSG_LEN (32)

static struct udp_pcb *g_test_serv_pcb = NULL;

static void
l2test_pbuf_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  u16_t len = p->len;
  unsigned char *data = (unsigned char *)(p->payload);
  int i;

  (void)arg;
  (void)pcb;
  (void)addr;
  (void)port;

  PRINTK("recv from ");
  for (i = 0; i < NETIF_MAX_HWADDR_LEN; i++) {
    if (i == 0) {
      PRINTK("%02x", p->mac_address[i]);
    } else {
      PRINTK(":%02x", p->mac_address[i]);
    }
  }
  PRINTK(" %s:%hu\n", ip6addr_ntoa(&(addr->u_addr.ip6)), port);
  PRINTK("RSSI : %hhd\n", PBUF_GET_RSSI(p));
  PRINTK("recv len : %hu, data : %.*s\n", len, len, data);

  return;
}

static err_t
l2test_pbuf_stop(void)
{
  if (g_test_serv_pcb != NULL) {
    udp_remove(g_test_serv_pcb);
    g_test_serv_pcb = NULL;
  }

  return LOS_OK;
}

static err_t
l2test_pbuf_start(struct netif *netif)
{
  err_t result;

  if (g_test_serv_pcb != NULL) {
    PRINTK("already start\n");
    return ERR_OK;
  }
  g_test_serv_pcb = udp_new_ip6();
  if (g_test_serv_pcb == NULL) {
    PRINTK("udp_new_ip6 failed\n");
    return ERR_MEM;
  }
  ip_set_option(g_test_serv_pcb, SOF_BROADCAST);
  result = udp_bind(g_test_serv_pcb, IP6_ADDR_ANY, L2_TEST_PORT);
  if (result != ERR_OK) {
    PRINTK("udp_bind failed\n");
    udp_remove(g_test_serv_pcb);
    g_test_serv_pcb = NULL;
    return result;
  }

  result = udp_connect(g_test_serv_pcb, IP6_ADDR_ANY, L2_TEST_PORT);
  if (result != ERR_OK) {
    PRINTK("udp_connect failed\n");
    udp_remove(g_test_serv_pcb);
    g_test_serv_pcb = NULL;
    return result;
  }
  g_test_serv_pcb->ifindex = netif->ifindex;
  udp_recv(g_test_serv_pcb, l2test_pbuf_recv, NULL);

  return result;
}

static err_t
l2test_pbuf_send(struct netif *netif, int argc, char **argv)
{
  err_t err;
  ip_addr_t dst_addr = {0};
  char msg[L2_PBUF_MSG_LEN] = {0};
  struct pbuf *p_out = NULL;
  int pri;

  if (g_test_serv_pcb == NULL) {
    PRINTK("pcb not init\n");
    return ERR_VAL;
  }

  if (ip6addr_aton(argv[3], &(dst_addr.u_addr.ip6)) == ERR_OK) {
    PRINTK("invalid ip6 addr\n");
    return ERR_ARG;
  }
  PRINTK("dst ip6 %s, priority %s\n", ip6addr_ntoa(&(dst_addr.u_addr.ip6)), argv[4]);
  if (sprintf_s(msg, sizeof(msg), "send msg priority %s", argv[4]) == -1) {
    return ERR_MEM;
  }
  IP_SET_TYPE_VAL(dst_addr, IPADDR_TYPE_V6);
  p_out = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(strlen(msg)), PBUF_RAM);
  if (p_out == NULL) {
    PRINTK("pbuf_alloc failed\n");
    return ERR_MEM;
  }
  err = memcpy_s(p_out->payload, (u16_t)(strlen(msg)), msg, (u16_t)(strlen(msg)));
  if (err != EOK) {
    PRINTK("memcpy_s failed\n");
    (void)pbuf_free(p_out);
    return err;
  }

  pri = atoi(argv[4]);
  /* 3 : beacon priority */
  g_test_serv_pcb->priority = (pri > 3) ? 3 : pri;
  /* 6 argc index is six and argv is five */
  if ((argc == 6) && (strcmp(argv[5], "ctrl") == ERR_OK)) {
    p_out->flags |= PBUF_FLAG_CTRL_PKT;
  }

  pbuf_realloc(p_out, (u16_t)(strlen(msg)));

  err = udp_sendto_if(g_test_serv_pcb, p_out, &dst_addr, L2_TEST_PORT, netif);
  PRINTK("send [%s] %d\n", msg, err);
  (void)pbuf_free(p_out);

  return err;
}

static err_t
l2test_remove_peer(struct netif *netif, char *mac_str)
{
  err_t ret;
  struct linklayer_addr peer_addr = {0};
  char *digit = NULL;
  u32_t mac_addr_len = strlen(mac_str) + 1;
  char tmp_str[MAX_MACADDR_STRING_LENGTH];
  char *tmp_str1 = NULL;
  char *save_ptr = NULL;
  int j;

  if (mac_addr_len != MAX_MACADDR_STRING_LENGTH) {
    PRINTK("wrong MAC address format\n");
    return LOS_NOK;
  }

  ret = strncpy_s(tmp_str, mac_addr_len, mac_str, mac_addr_len - 1);
  if (ret != EOK) {
    PRINTK("strncpy_s failed\n");
    return LOS_NOK;
  }
  for (j = 0, tmp_str1 = tmp_str; j < NETIF_MAX_HWADDR_LEN; j++, tmp_str1 = NULL) {
    digit = strtok_r(tmp_str1, ":", &save_ptr);
    if ((digit == NULL) || (strlen(digit) > BYTE_IN_HEX_LEN)) {
      PRINTK("wrong MAC address format\n");
      return LOS_NOK;
    }
    CONVERT_STRING_TO_HEX(digit, peer_addr.addr[j]);
  }
  peer_addr.addrlen = NETIF_MAX_HWADDR_LEN;
  ret = netif_remove_peer(netif, &peer_addr);

  return ret;
}

static err_t
l2test_callback_status(struct netif *netif)
{
#if LWIP_IPV4 && LWIP_IGMP && LWIP_LINK_MCAST_FILTER
  PRINTK("igmp_mac_filter %s\n", ((netif->igmp_mac_filter == NULL) ? "null" : "not null"));
#endif /* LWIP_IPV4 && LWIP_IGMP && LWIP_LINK_MCAST_FILTER */
#if LWIP_IPV6 && LWIP_IPV6_MLD && LWIP_LINK_MCAST_FILTER
  PRINTK("mld_mac_filter %s\n", ((netif->mld_mac_filter == NULL) ? "null" : "not null"));
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD && LWIP_LINK_MCAST_FILTER */
  PRINTK("remove_peer %s\n", ((netif->remove_peer == NULL) ? "null" : "not null"));
  PRINTK("set_beacon_prio %s\n", ((netif->set_beacon_prio == NULL) ? "null" : "not null"));
  PRINTK("set_unique_id %s\n", ((netif->set_unique_id == NULL) ? "null" : "not null"));
  PRINTK("linklayer_event %s\n", ((netif->linklayer_event == NULL) ? "null" : "not null"));

  return LOS_OK;
}

static void
os_shell_l2test_usage(void)
{
  PRINTK("l2test\n");
  PRINTK("\t%-32s%s\n", "ifname remove mac_addr_str", "disassociate peer through MAC address. {l2test wlan0 remove \
      11:22:33:44:55:66}");
  PRINTK("\t%-32s%s\n", "ifname prio priority", "set beacon priority, value of priority is 0~255. {l2test wlan0 prio \
      56}");
  PRINTK("\t%-32s%s\n", "ifname mnid mnid_value", "set mnid of mesh node, value of mnid is 0~127. {l2test wlan0 mnid \
      2}");
  PRINTK("\t%-32s%s\n", "ifname all", "show callback functions of netif registered status. {l2test wlan0 all}");
  PRINTK("\t%-32s%s\n", "ifname pbuf {start | stop}", "start/stop a udp pcb");
  PRINTK("\t%-32s\n", "ifname pbuf send dst_ip6_ip priority_value(0,1,2,3) [ctrl]");
  PRINTK("\t%-32s%s\n", "", "send a message to dst_ip6_ip, priority_value can be one in (0,1,2,3), 'ctrl' is \
      optional");
  PRINTK("\t%-32s\n", "store {read | write} {ver | flag | dtsn | dodagVerNum | pathSeq | daoSeq | dcoSeq} [value]");
  PRINTK("\t%-32s%s\n", "", "range of value is 0~255");

  return;
}

static err_t
l2test_store_read_or_write(char *nv_ctrl, u8_t *is_read)
{
  if (strcmp(nv_ctrl, "read") == ERR_OK) {
    *is_read = lwIP_TRUE;
  } else if (strcmp(nv_ctrl, "write") == ERR_OK) {
    *is_read = lwIP_FALSE;
  } else {
    os_shell_l2test_usage();
    goto failure;
  }
  return ERR_OK;
failure:
  return ERR_ARG;
}

static err_t
l2test_store_key_id(char *nv_key, u8_t *nv_key_id)
{
  if (strcmp(nv_key, "ver") == ERR_OK) {
    *nv_key_id = PS_VER;
  } else if (strcmp(nv_key, "flag") == ERR_OK) {
    *nv_key_id = PS_FLAG;
  } else if (strcmp(nv_key, "dtsn") == ERR_OK) {
    *nv_key_id = PS_DTSN;
  } else if (strcmp(nv_key, "dodagVerNum") == ERR_OK) {
    *nv_key_id = PS_DODAGVERNUM;
  } else if (strcmp(nv_key, "pathSeq") == ERR_OK) {
    *nv_key_id = PS_PATHSEQ;
  } else if (strcmp(nv_key, "daoSeq") == ERR_OK) {
    *nv_key_id = PS_DAOSEQ;
  } else if (strcmp(nv_key, "dcoSeq") == ERR_OK) {
    *nv_key_id = PS_DCOSEQ;
  } else {
    os_shell_l2test_usage();
    goto failure;
  }
  return ERR_OK;
failure:
  return ERR_ARG;
}

static err_t
l2test_store(int argc, char **argv)
{
  err_t ret;
  u8_t is_read = lwIP_TRUE;
  u8_t nv_key_id;
  u8_t value;
  if (argv == NULL) {
    return LOS_NOK;
  }
  ret = l2test_store_read_or_write(argv[1], &is_read);
  if (ret != ERR_OK) {
    goto failure;
  }
  if ((is_read == lwIP_FALSE) && (argc != 4)) { /* 4 ：argc index */
    os_shell_l2test_usage();
    goto failure;
  }
  ret = l2test_store_key_id(argv[2], &nv_key_id);
  if (ret != ERR_OK) {
    goto failure;
  }

  if (is_read == lwIP_TRUE) {
    ret = rpl_pstore_read(nv_key_id, &value, sizeof(value));
    if (ret == ERR_OK) {
      PRINTK("read %s %hhu\n", argv[2], value);
    }
  } else {
    value = (u8_t)atoi(argv[3]);
    ret = rpl_pstore_write(nv_key_id, &value, sizeof(value));
    if (ret == ERR_OK) {
      PRINTK("write %s %hhu\n", argv[2], value);
    }
  }

  return ret;
failure:
  return ERR_ARG;
}

static void
os_shell_l2test_internal(void *arg)
{
  err_t ret = ERR_VAL;
  struct netif *netif = NULL;
  u8_t prio;
  uniqid_t id;
  shell_cmd_t *l2test_cmd = (shell_cmd_t *)arg;
  int argc = l2test_cmd->argc;
  char **argv = l2test_cmd->argv;

  if (argc < 1) {
    os_shell_l2test_usage();
    sys_sem_signal(&l2test_cmd->cb_completed);
    return;
  }
  if ((argc >= 3) && (strcmp(argv[0], "store") == ERR_OK)) {
    ret = l2test_store(argc, argv);
    goto funcRet;
  }
  netif = netif_find(argv[0]);
  if (netif == NULL) {
    PRINTK("not find %s\n", argv[0]);
    sys_sem_signal(&l2test_cmd->cb_completed);
    return;
  }
  if ((argc == 3) && (strcmp(argv[1], "remove") == ERR_OK)) {
    ret = l2test_remove_peer(netif, argv[2]);
  } else if ((argc == 3) && (strcmp(argv[1], "prio") == ERR_OK)) {
    /* value of priority is 0~255 */
    if ((atoi(argv[2]) < 0) || (atoi(argv[2]) > 255)) {
      PRINTK("invalid prio\n");
      ret = -1;
      goto funcRet;
    }
    prio = (u8_t)(atoi(argv[2]));
    ret = netif_set_beacon_prio(netif, prio);
  } else if ((argc == 3) && (strcmp(argv[1], "mnid") == ERR_OK)) {
    /* value of mnid is 0~127 */
    if ((atoi(argv[2]) < 0) || (atoi(argv[2]) > 127)) {
      PRINTK("invalid mnid\n");
      ret = -1;
      goto funcRet;
    }
    id = (uniqid_t)(atoi(argv[2]));
    ret = netif_set_unique_id(netif, id);
  } else if ((argc == 2) && (strcmp(argv[1], "all") == ERR_OK)) {
    ret = l2test_callback_status(netif);
  } else if ((argc >= 3) && (strcmp(argv[1], "pbuf") == ERR_OK)) {
    if (strcmp(argv[2], "start") == ERR_OK) {
      ret = l2test_pbuf_start(netif);
    } else if (strcmp(argv[2], "stop") == ERR_OK) {
      ret = l2test_pbuf_stop();
    } else if ((argc >= 5) && (strcmp(argv[2], "send") == ERR_OK)) {
      ret = l2test_pbuf_send(netif, argc, argv);
    } else {
      os_shell_l2test_usage();
    }
  } else {
    os_shell_l2test_usage();
  }

funcRet:
  PRINTK("ret %d\n", ret);

  sys_sem_signal(&l2test_cmd->cb_completed);
  return;
}

u32_t
os_shell_l2test(int argc, char **argv)
{
  shell_cmd_t l2test_cmd = {0};
  err_t ret;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (sys_sem_new(&l2test_cmd.cb_completed, 0) != ERR_OK) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s: sys_sem_new fail\n", __FUNCTION__);
#else
    PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
#endif
    return LOS_NOK;
  }

  l2test_cmd.argc = argc;
  l2test_cmd.argv = argv;

  ret = tcpip_callback(os_shell_l2test_internal, &l2test_cmd);
  if (ret != ERR_OK) {
    sys_sem_free(&l2test_cmd.cb_completed);
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("l2test : internal error, ret:%d\n", ret);
#else
    PRINTK("l2test : internal error, ret:%d\n", ret);
#endif
    return LOS_NOK;
  }
  (void)sys_arch_sem_wait(&l2test_cmd.cb_completed, 0);
  sys_sem_free(&l2test_cmd.cb_completed);

  return LOS_OK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(l2test_shellcmd, CMD_TYPE_EX, "l2test", XARGS, (CmdCallBackFunc)os_shell_l2test);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_RIPPLE */

#endif /* LWIP_ENABLE_MESH_SHELL_CMD */

#endif /* LWIP_ENABLE_BASIC_SHELL_CMD */

#if LWIP_ENABLE_LOS_SHELL_CMD
static void
lwip_ifstats_usage(const char *cmd)
{
  PRINTK("Usage:"\
         "\n%s [-p [IPV6 | ICMPV6 | ND6 | 6LOWPAN | TCP |UDP]]\n", cmd);
}

#define PRINT_STAT(stats_info) \
  PRINTK("packets sent:%u \t recvd:%u \t drop:%u \t\n",stats_info->xmit, \
          stats_info->recv, stats_info->drop);

#if IP6_STATS
#define PRINT_IPV6_STAT() do { \
  stats_info = &lwip_stats.ip6; \
  PRINTK("IPv6 "); \
  PRINT_STAT(stats_info) \
} while (0)
#else
#define PRINT_IPV6_STAT()
#endif

#if ICMP6_STATS
#define PRINT_ICMPV6_STAT()  lwip_print_icmpv6_stat()
#else
#define PRINT_ICMPV6_STAT()
#endif

#if ND6_STATS
#define PRINT_ND6_STAT() do { \
  stats_info = &lwip_stats.nd6; \
  PRINTK("ND6 "); \
  PRINT_STAT(stats_info) \
} while (0)
#else
#define PRINT_ND6_STAT()
#endif

#if TCP_STATS
#define PRINT_TCP_STAT() do { \
  stats_info = &lwip_stats.tcp; \
  PRINTK("TCP "); \
  PRINT_STAT(stats_info) \
} while (0)
#else
#define PRINT_TCP_STAT()
#endif

#if UDP_STATS
#define PRINT_UDP_STAT() do { \
  stats_info = &lwip_stats.udp; \
  PRINTK("UDP "); \
  PRINT_STAT(stats_info) \
} while (0)
#else
#define PRINT_UDP_STAT()
#endif

#if LOWPAN6_STATS
#define PRINT_6LOWPAN_STAT() do { \
  struct stats_lowpan6 *stats = &lwip_stats.lowpan6; \
  PRINTK("6LOWPAN "); \
  PRINTK("pkt_xmit_succ:%u \t xmit_pkt_drop:%u " \
         "\t pkt_decomp_succ:%u \t recv_pkt_drop:%u \t\n", \
         stats->pkt_xmit,  (stats->pkt_from_ip - stats->pkt_xmit), \
         stats->pkt_to_ip, (stats->pkt_recvd - stats->pkt_to_ip)); \
} while (0)
#else
#define PRINT_6LOWPAN_STAT()
#endif

#if ICMP6_STATS
void
lwip_print_icmpv6_stat(void)
{
  struct stats_proto stats_info = lwip_stats.icmp6;
#if ND6_STATS
  stats_info.xmit = (STAT_COUNTER)(stats_info.xmit + lwip_stats.nd6.xmit);
#endif
#if LWIP_IPV6_MLD
  stats_info.xmit = (STAT_COUNTER)(stats_info.xmit + lwip_stats.mld6.xmit);
#endif

  PRINTK("ICMPv6 ");
  PRINT_STAT((&stats_info))
}
#endif

u32_t
lwip_ifstats(int argc, char **argv)
{
  if (!tcpip_init_finish) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  if (argc) {
    if ((argc < 2) || !argv) {
      goto SHOW_RETURN;
    }

    if (argv[0] && argv[1] && strcasecmp("-p", argv[0]) == 0) {
#if IP6_STATS || ICMP6_STATS || TCP_STATS || UDP_STATS
      struct stats_proto *stats_info = NULL;
#endif
      if (strcasecmp("IPV6", argv[1]) == 0) {
#if IP6_STATS
        PRINT_IPV6_STAT();
#endif
      } else if (strcasecmp("ICMPV6", argv[1]) == 0) {
        PRINT_ICMPV6_STAT();
      } else if (strcasecmp("ND6", argv[1]) == 0) {
        PRINT_ND6_STAT();
      } else if (strcasecmp("TCP", argv[1]) == 0) {
        PRINT_TCP_STAT();
      } else if (strcasecmp("UDP", argv[1]) == 0) {
        PRINT_UDP_STAT();
      } else if (strcasecmp("6LOWPAN", argv[1]) == 0) {
        PRINT_6LOWPAN_STAT();
      } else {
        goto SHOW_RETURN;
      }
    } else {
      goto SHOW_RETURN;
    }
  } else {
#if IP6_STATS || ICMP6_STATS || TCP_STATS || UDP_STATS
    struct stats_proto *stats_info = NULL;
#endif
    /* Show Statistics for IPv6, ICMPv6, ND6, 6LOWPAN, UDP and TCP */
    PRINT_IPV6_STAT();
    PRINT_ICMPV6_STAT();
    PRINT_ND6_STAT();
    PRINT_TCP_STAT();
    PRINT_UDP_STAT();
    PRINT_6LOWPAN_STAT();
  }

  return 0;

SHOW_RETURN:
  lwip_ifstats_usage("ifstats");
  return 1;
}

/* add arp entry to arp cache */
#define ARP_OPTION_ADD      1
/* delete arp entry to arp cache */
#define ARP_OPTION_DEL      2
/* print all arp entry in arp cache */
#define ARP_OPTION_SHOW     3

struct arp_option {
  /* see the ARP_OPTION_ above */
  int             option;
  /* descriptive abbreviation of network interface */
  char            iface[IFNAMSIZ];
  /* ip addr */
  unsigned int    ipaddr;
  /* hw addr */
  unsigned char ethaddr[ETH_HWADDR_LEN];
  /* when using telnet, printf to the telnet socket will result in system  */
  /* deadlock.so don't do it.cahe the data to prinf to a buf, and when     */
  /* callback returns, then printf the data out to the telnet socket       */
  sys_sem_t       cb_completed;
  char            cb_print_buf[PRINT_BUF_LEN];
  int             print_buf_len;
};

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void
lwip_arp_show_internal(struct netif *netif, char *printf_buf, unsigned int buf_len)
{
  u8_t state, i, num;
  int ret;
  char *name = NULL;
  char *tmp = printf_buf;
  ret = snprintf_s(tmp, buf_len, (buf_len - 1), "%-24s%-24s%-12s%-12s\n", "Address", "HWaddress", "Iface", "Type");
  if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
    return;
  }
  tmp += ret;
  buf_len -= (unsigned int)ret;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    state = arp_table[i].state;
    if (((state == ETHARP_STATE_STABLE)
#if ETHARP_SUPPORT_STATIC_ENTRIES
         || (state == ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        ) && arp_table[i].netif) {
      name = arp_table[i].netif->name;
      num = arp_table[i].netif->num;
      if ((netif != NULL) && ((strncmp(name, netif->name, IFNAMSIZ) != 0) || (num != netif->num))) {
        continue;
      }

      ret = snprintf_s(tmp, buf_len, (buf_len - 1),
                       "%-24s%02X:%02X:%02X:%02X:%02X:%02X       %s%u        %s\n",
                       ip4addr_ntoa(&arp_table[i].ipaddr),
                       arp_table[i].ethaddr.addr[0], arp_table[i].ethaddr.addr[1],
                       arp_table[i].ethaddr.addr[2], arp_table[i].ethaddr.addr[3],
                       arp_table[i].ethaddr.addr[4], arp_table[i].ethaddr.addr[5],
                       name, num,
#if ETHARP_SUPPORT_STATIC_ENTRIES
                       ((state == ETHARP_STATE_STATIC) ? "static" : "dynamic")
#else
                       "dynamic"
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
                      );
      if ((ret <= 0) || ((unsigned int)ret >= buf_len)) {
        return;
      }
      tmp += ret;
      buf_len -= (unsigned int)ret;
    }
  }
}

static int
lwip_arp_add_internal(struct netif *netif, struct arp_option *arp_cmd)
{
  err_t ret = 0;
  struct eth_addr ethaddr;
  ip4_addr_t ipaddr;
  ipaddr.addr = arp_cmd->ipaddr;
  (void)memcpy_s(ethaddr.addr, sizeof(ethaddr.addr), arp_cmd->ethaddr, sizeof(ethaddr.addr));
  if (netif != NULL) {
    /* If  in the same subnet */
    if (ip4_addr_netcmp(&ipaddr, ip_2_ip4(&(netif->ip_addr)), ip_2_ip4(&(netif->netmask)))) {
      ret = etharp_update_arp_entry(netif, &ipaddr, &ethaddr, ETHARP_FLAG_TRY_HARD);
    } else {
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1),
                       "Network is unreachable\n");
      sys_sem_signal(&arp_cmd->cb_completed);
      return ERR_NETUNREACH;
    }
  } else {
    for (netif = netif_list; netif != NULL; netif = netif->next) {
      /* If  in the same subnet */
      if (ip4_addr_netcmp(&ipaddr, ip_2_ip4(&(netif->ip_addr)), ip_2_ip4(&(netif->netmask)))) {
        ret = etharp_update_arp_entry(netif, &ipaddr, &ethaddr, ETHARP_FLAG_TRY_HARD);
        if (ret == ERR_OK) {
          /* only can add success one time */
          break;
        }
      }
      /* The netif is last netif and cannot add this arp entry on any netif */
      if (netif->next == NULL) {
        (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1),
                         "Network is unreachable\n");
        sys_sem_signal(&arp_cmd->cb_completed);
        return ERR_NETUNREACH;
      }
    }
  }
  return ret;
}

static int
lwip_arp_del_internal(struct netif *netif, struct arp_option *arp_cmd)
{
  err_t ret = 0;
  struct eth_addr ethaddr;
  ip4_addr_t ipaddr;
  ipaddr.addr = arp_cmd->ipaddr;
  (void)memcpy_s(ethaddr.addr, sizeof(ethaddr.addr), arp_cmd->ethaddr, sizeof(ethaddr.addr));
  if (netif != NULL) {
    ret = etharp_delete_arp_entry(netif, &ipaddr);
  } else {
    for (netif = netif_list; netif != NULL; netif = netif->next) {
      ret = etharp_delete_arp_entry(netif, &ipaddr);
      if (ret == ERR_OK) {
        /* only can del success one time */
        break;
      }
    }
  }
  return ret;
}

#ifndef LWIP_TESTBED
LWIP_STATIC
#endif
void
lwip_arp_internal(void *arg)
{
#if LWIP_IPV4
  struct arp_option *arp_cmd = (struct arp_option *)arg;
  struct netif *netif = NULL;
  err_t ret = 0;
  int type = 0;

  if (arp_cmd->iface[0] == 'd' && arp_cmd->iface[1] == 'e') {
    netif = NULL;
  } else {
    /* find the specified netif by it's name */
    netif = netif_find(arp_cmd->iface);
    if (netif == NULL) {
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1), "No such device\n");
      goto out;
    }
  }

  type = arp_cmd->option;
  switch (type) {
    case ARP_OPTION_SHOW:
      lwip_arp_show_internal(netif, arp_cmd->cb_print_buf, PRINT_BUF_LEN);
      break;

    case ARP_OPTION_ADD:
      ret = lwip_arp_add_internal(netif, arp_cmd);
      break;

    case ARP_OPTION_DEL:
      ret = lwip_arp_del_internal(netif, arp_cmd);
      break;

    default:
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1), "Error\n");
      goto out;
  }

out:
  if (type == ARP_OPTION_ADD || type == ARP_OPTION_DEL) {
    if (ret == ERR_NETUNREACH) {
      return;
    } else if (ret == ERR_MEM) {
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1), "Out of memory error\n");
    } else if (ret == ERR_ARG) {
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1), "Illegal argument\n");
    } else {
      (void)snprintf_s(arp_cmd->cb_print_buf, PRINT_BUF_LEN, (PRINT_BUF_LEN - 1), "Successed\n");
    }
  }
#endif

  sys_sem_signal(&arp_cmd->cb_completed);
}

LWIP_STATIC void
lwip_arp_usage(const char *cmd)
{
  PRINTK("Usage:"\
         "\n%s"
         "\n%s [-i IF] -s IPADDR HWADDR"\
         "\n%s [-i IF] -d IPADDR\n",
         cmd, cmd, cmd);
}

static void
arp_cmd_init(struct arp_option *arp_cmd_p)
{
  (void)memset_s(arp_cmd_p, sizeof(struct arp_option), 0, sizeof(struct arp_option));
  arp_cmd_p->iface[0] = 'd';
  arp_cmd_p->iface[1] = 'e';
  arp_cmd_p->iface[2] = '0';
  arp_cmd_p->option = ARP_OPTION_SHOW;
  arp_cmd_p->print_buf_len = 0;
}

static int
arp_parse_get(const char *ifname, const int iface_len, struct arp_option *arp_cmd_p)
{
  if (iface_len >= IFNAMSIZ) {
    PRINTK("Iface name is big \n");
    return LOS_NOK;
  }
  if (strncmp(ifname, "lo", (sizeof("lo") - 1)) == 0) {
    PRINTK("Illegal operation\n");
    return LOS_NOK;
  }
  (void)strncpy_s(arp_cmd_p->iface, IFNAMSIZ, ifname, iface_len);
  arp_cmd_p->iface[iface_len] = '\0';
  return LOS_OK;
}

static int
arp_parse_add(const unsigned int ipaddr, const unsigned char *macaddr, struct arp_option *arp_cmd_p)
{
  /* arp add */
  char *digit = NULL;
  u32_t macaddrlen = strlen(macaddr) + 1;
  char tmp_str[MAX_MACADDR_STRING_LENGTH];
  char *tmp_str1 = NULL;
  char *saveptr1 = NULL;
  char *temp = NULL;
  int j;

  arp_cmd_p->option = ARP_OPTION_ADD;
  arp_cmd_p->ipaddr = ipaddr;

  if (arp_cmd_p->ipaddr == IPADDR_NONE) {
    PRINTK("IP address is not correct!\n");
    return LOS_NOK;
  }

  /* cannot add an arp entry of 127.*.*.* */
  if ((arp_cmd_p->ipaddr & (u32_t)0x0000007fUL) == (u32_t)0x0000007fUL) {
    PRINTK("IP address is not correct!\n");
    return LOS_NOK;
  }

  if (macaddrlen != MAX_MACADDR_STRING_LENGTH) {
    PRINTK("Wrong MAC address length\n");
    return LOS_NOK;
  }

  if (strncpy_s(tmp_str, MAX_MACADDR_STRING_LENGTH, macaddr, macaddrlen - 1) != EOK) {
    PRINTK("Wrong MAC address\n");
    return LOS_NOK;
  }
  /* 6 : the : index in mac address */
  for (j = 0, tmp_str1 = tmp_str; j < 6; j++, tmp_str1 = NULL) {
    digit = strtok_r(tmp_str1, ":", &saveptr1);
    if ((digit == NULL) || (strlen(digit) > 2)) { /* 2 : Addresses are classify in two hexadecimal */
      PRINTK("MAC address is not correct\n");
      return LOS_NOK;
    }

    for (temp = digit; *temp != '\0'; temp++) {
      if (!isxdigit(*temp)) {
        PRINTK("MAC address is not correct\n");
        return LOS_NOK;
      }
    }

    CONVERT_STRING_TO_HEX(digit, arp_cmd_p->ethaddr[j]);
  }
  return LOS_OK;
}

static int
arp_cmd_exec_callback(struct arp_option *arp_cmd_p)
{
  err_t ret;
  if (sys_sem_new(&arp_cmd_p->cb_completed, 0) != ERR_OK) {
    PRINTK("%s: sys_sem_new fail\n", __FUNCTION__);
    return LOS_NOK;
  }

  if ((ret = tcpip_callback(lwip_arp_internal, arp_cmd_p)) != ERR_OK) {
    PRINTK("%s : tcpip_callback failed in line %d : errnu %d", __FUNCTION__, __LINE__, ret);
    sys_sem_free(&arp_cmd_p->cb_completed);
    return LOS_NOK;
  }
  (void)sys_arch_sem_wait(&arp_cmd_p->cb_completed, 0);
  sys_sem_free(&arp_cmd_p->cb_completed);
  arp_cmd_p->cb_print_buf[PRINT_BUF_LEN - 1] = '\0';
  PRINTK("%s", arp_cmd_p->cb_print_buf);
  return LOS_OK;
}

u32_t
lwip_arp(int argc, char **argv)
{
  int i = 0;
  struct arp_option arp_cmd;
  err_t ret;
  char *ifname;
  int inf_len;
  unsigned int ipaddr;
  unsigned char *macaddr = NULL;

  arp_cmd_init(&arp_cmd);
  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  while (argc > 0) {
    if (strcmp("-i", argv[i]) == 0 && (argc > 1)) {
      inf_len = strlen(argv[i + 1]);
      (void)strncpy_s(ifname, inf_len, argv[i + 1], inf_len);
      ret = arp_parse_get(ifname, inf_len, &arp_cmd);
      if (ret == LOS_NOK) {
        goto arp_error;
      }

      i += 2;
      argc -= 2;
    } else if (strcmp("-d", argv[i]) == 0 && (argc > 1)) {
      /* arp delete */
      arp_cmd.option = ARP_OPTION_DEL;
      arp_cmd.ipaddr = inet_addr(argv[i + 1]);

      if (arp_cmd.ipaddr == IPADDR_NONE) {
        PRINTK("IP address is not correct!\n");
        goto arp_error;
      }

      i += 2;
      argc -= 2;
    } else if (strcmp("-s", argv[i]) == 0 && (argc > 2)) {
      ipaddr = inet_addr(argv[i + 1]);
      (void)strncpy_s(macaddr, strlen(argv[i + 2]), argv[i + 2], strlen(argv[i + 2]));
      ret = arp_parse_add(ipaddr, macaddr, &arp_cmd);
      if (ret == LOS_NOK) {
        goto arp_error;
      }

      i += 3;
      argc -= 3;
    } else {
      goto arp_error;
    }
  }

  ret = arp_cmd_exec_callback(&arp_cmd);
  return ret;

arp_error:
  lwip_arp_usage("arp");
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(arp_shellcmd, CMD_TYPE_EX, "arp", 1, (CmdCallBackFunc)lwip_arp);
#endif /* LOSCFG_SHELL */

void
ifup_internal(void *arg)
{
  struct netif *netif = NULL;
  struct if_cmd_data *ifcmd_data = NULL;

  ifcmd_data = (struct if_cmd_data *)arg;
  netif = netif_find(ifcmd_data->if_name);
  if (netif == NULL) {
    ifcmd_data->err = ERR_VAL;
  } else {
    (void)netif_set_up(netif);
    ifcmd_data->err = ERR_OK;
  }

  sys_sem_signal(&ifcmd_data->cb_completed);
  return;
}

void
ifdown_internal(void *arg)
{
  struct netif *netif = NULL;
  struct if_cmd_data *ifcmd_data = NULL;

  ifcmd_data = (struct if_cmd_data *)arg;
  netif = netif_find(ifcmd_data->if_name);
  if (netif == NULL) {
    ifcmd_data->err = ERR_VAL;
  } else {
    (void)netif_set_down(netif);
    ifcmd_data->err = ERR_OK;
  }

  sys_sem_signal(&ifcmd_data->cb_completed);
  return;
}

#if  LWIP_SNTP
u32_t
osShellNtpdate(int argc, char **argv)
{
  int server_num;
  char *ret = NULL;
  struct timeval get_time;

  (void)memset_s(&get_time, sizeof(struct timeval), 0, sizeof(struct timeval));

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (argc < 1) {
    goto usage;
  }

  server_num = lwip_sntp_start(argc, argv, &get_time);
  if (server_num >= 0 && server_num < argc) {
    ret = ctime((time_t *)&get_time.tv_sec);
    if (ret) {
      PRINTK("time server %s: %s\n", argv[server_num], ret);
    } else {
      PRINTK("ctime return null error\n");
    }
  } else {
    PRINTK("no server suitable for synchronization found\n");
  }

  return LOS_OK;

usage:
  PRINTK("\nUsage:\n");
  PRINTK("ntpdate [SERVER_IP1] [SERVER_IP2] ...\n");
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ntpdate_shellcmd, CMD_TYPE_EX, "ntpdate",  XARGS, (CmdCallBackFunc)osShellNtpdate);
#endif /* LOSCFG_SHELL */

#endif /* LWIP_SNTP */

#ifdef LOSCFG_NET_LWIP_SACK_TFTP
static char *tftp_error[] = {
  "TFTP transfer finish\n",
  "Error while creating UDP socket\n",
  "Error while binding to the UDP socket\n",
  "Error returned by lwip_select() system call\n",
  "Error while receiving data from the peer\n",
  "Error while sending data to the peer\n",
  "Requested file is not found\n",
  "This is the error sent by the server when hostname cannot be resolved\n",
  "Input paramters passed to TFTP interfaces are invalid\n",
  "Error detected in TFTP packet or the error received from the TFTP server\n",
  "Error during packet synhronization while sending or unexpected packet is received\n",
  "File size limit crossed, Max block can be 0xFFFF, each block containing 512 bytes\n",
  "File name lenght greater than 256\n",
  "Hostname IP is not valid\n",
  "TFTP server returned file access error\n",
  "TFTP server returned error signifying that the DISK is full to write\n",
  "TFTP server returned error signifying that the file exist\n",
  "The source file name do not exisits\n",
  "Memory allocaion failed in TFTP client\n",
  "File open failed\n",
  "File read error\n",
  "File create error\n",
  "File write error\n",
  "Max time expired while waiting for file to be recived\n",
  "Error when the received packet is less than 4bytes(error lenght) or greater than 512bytes\n",
  "Returned by TFTP server for protocol user error\n",
  "The destination file path length greater than 256\n",
  "Returned by TFTP server for undefined transfer ID\n",
  "IOCTL fucntion failed at TFTP client while setting the socket to non-block\n",
};

#if LWIP_TFTP
static u32_t
tftp_invoke_operation(u8_t uc_tftp_get, u32_t ul_remote_addr, s8_t *sz_local_file_name, s8_t *sz_remote_file_name)
{
  u16_t us_tftp_serv_port = 69;
  u32_t ret;
  if (sz_local_file_name == NULL || sz_remote_file_name == NULL) {
    return LOS_NOK;
  }

  if (uc_tftp_get) {
    ret = lwip_tftp_get_file_by_filename(ntohl(ul_remote_addr), us_tftp_serv_port,
                                         TRANSFER_MODE_BINARY, sz_remote_file_name, sz_local_file_name);
  } else {
    ret = lwip_tftp_put_file_by_filename(ntohl(ul_remote_addr), us_tftp_serv_port,
                                         TRANSFER_MODE_BINARY, sz_local_file_name, sz_remote_file_name);
  }

  LWIP_ASSERT("TFTP UNKNOW ERROR!", ret < LWIP_ARRAYSIZE(tftp_error));
  PRINTK("%s", tftp_error[ret]);
  if (ret) {
    return LOS_NOK;
  } else {
    return LOS_OK;
  }
}

u32_t
osShellTftp(int argc, char **argv)
{
  /* log off temporary for upgrade lwip to 2.0 */
  u32_t  ul_remote_addr = IPADDR_NONE;
  u8_t   uc_tftp_get = 0;
  s8_t   *sz_local_file_name = NULL;
  s8_t   *sz_remote_file_name = NULL;
  u32_t  ret;
  int i = 0;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (!tcpip_init_finish) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    return LOS_NOK;
  }

  while (i < argc) {
    if (strcmp(argv[i], "-p") == 0) {
      uc_tftp_get = 0;
      i++;
      continue;
    }

    if (strcmp(argv[i], "-g") == 0) {
      uc_tftp_get = 1;
      i++;
      continue;
    }

    if (strcmp(argv[i], "-l") == 0 && ((i + 1) < argc)) {
      sz_local_file_name = (s8_t *)argv[i + 1];
      i += 2;
      continue;
    }

    if (strcmp(argv[i], "-r") == 0 && ((i + 1) < argc)) {
      sz_remote_file_name = (s8_t *)argv[i + 1];
      i += 2;
      continue;
    }

    if ((i + 1) == argc) {
      ul_remote_addr = inet_addr(argv[i]);
      break;
    }

    goto usage;
  }

  if (ul_remote_addr == IPADDR_NONE || sz_local_file_name == NULL || sz_remote_file_name == NULL) {
    goto usage;
  }

  return tftp_invoke_operation(uc_tftp_get, ul_remote_addr, sz_local_file_name, sz_remote_file_name);

usage:
  PRINTK("usage:\nTransfer a file from/to tftp server\n");
  PRINTK("tftp <-g/-p> -l FullPathLocalFile -r RemoteFile Host\n");
  return LOS_NOK;
}
#endif /* LWIP_TFTP */

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(tftp_shellcmd, CMD_TYPE_EX, "tftp", XARGS, (CmdCallBackFunc)osShellTftp);
#endif /* LOSCFG_SHELL */
#endif /* LOSCFG_NET_LWIP_SACK_TFTP */

#define MAX_SIZE 1024
void
tcp_access(int sockfd)
{
  size_t n, i;
  ssize_t ret;
  char msg[MAX_SIZE] = {0};
  while (1) {
    PRINTK("waiting for recv\n");
    (void)memset_s(msg, MAX_SIZE, 0, MAX_SIZE);
    ret = recv(sockfd, msg, MAX_SIZE - 1, 0);
    if (ret < 0) {
      PRINTK("recv failed, %d.\n", (u32_t)ret);
      (void)closesocket(sockfd);
      return;
    } else if (ret == 0) {
      (void)closesocket(sockfd);
      PRINTK("client disconnect.\n");
      return;
    }

    n = strlen(msg);
    for (i = 0; i < n; ++i) {
      if ((msg[i] >= 'a') && (msg[i] <= 'z')) {
        msg[i] = (char)(msg[i] + ('A' - 'a'));
      } else if ((msg[i] >= 'A') && (msg[i] <= 'Z')) {
        msg[i] = (char)(msg[i] + ('a' - 'A'));
      }
    }

    if (send(sockfd, msg, n, 0) < 0) {
      PRINTK("send failed!\r\n");
      continue;
    }
  }
}

#ifdef LWIP_DEBUG_TCPSERVER
u32_t
osTcpserver(int argc, char **argv)
{
  uint16_t port;
  int sockfd;
  int ret;
  struct sockaddr_in seraddr;
  struct sockaddr_in cliaddr;
  u32_t cliaddr_size = (u32_t)sizeof(cliaddr);
  int reuse, i_port_val;

  if (tcpip_init_finish == 0) {
    PRINTK("tcpip_init have not been called\n");
    return LOS_NOK;
  }

  if (argc < 1) {
    PRINTK("\nUsage: tcpserver <port>\n");
    return LOS_NOK;
  }

  i_port_val = atoi(argv[0]);
  /* Port 0 not supported , negative values not supported , max port limit is 65535 */
  if (i_port_val <= 0 || i_port_val > 65535) {
    PRINTK("\nUsage: Invalid port\n");
    return LOS_NOK;
  }

  port = (uint16_t)i_port_val;

  /*
   * removed the print of argv[1] as its accessing argv[1] without verifying argc and argv[1] not used anywhere else
   */
  PRINTK("argv[0]:%s, argc:%d, port:%d\r\n", argv[0], argc, port);
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  reuse = 1;
  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,
                 (const char *)&reuse, sizeof(reuse)) != 0) {
    (void)closesocket(sockfd);
    PRINTK("set SO_REUSEADDR failed\n");
    return LOS_NOK;
  }

  (void)memset_s(&seraddr, sizeof(seraddr), 0, sizeof(seraddr));
  seraddr.sin_family = AF_INET;
  seraddr.sin_addr.s_addr = htonl(INADDR_ANY);
  seraddr.sin_port = htons(port);

  ret = bind(sockfd, (struct sockaddr *)&seraddr, sizeof(seraddr));
  if (ret < 0) {
    PRINTK("bind ip and port failed");
    (void)closesocket(sockfd);
    return LOS_NOK;
  }

  ret = listen(sockfd, 5); /* 5 : max tcp listen backlog queue */
  if (ret < 0) {
    (void)closesocket(sockfd);
    PRINTK("listen failed\n");
    return LOS_NOK;
  }
  while (1) {
    PRINTK("waiting for accept\n");
    (void)memset_s(&cliaddr, sizeof(struct sockaddr_in), 0, sizeof(struct sockaddr_in));
    ret = (int)accept(sockfd, (struct sockaddr *)&cliaddr, &cliaddr_size);
    if (ret < 0) {
      (void)closesocket(sockfd);
      PRINTK("Accept failed, %d\n", ret);
      break ;
    }
    tcp_access(ret);
  }
  return LOS_NOK;            // Hits Only If Accept Fails
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(tcpserver_shellcmd, CMD_TYPE_EX, "tcpserver",  XARGS, (CmdCallBackFunc)osTcpserver);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_DEBUG_TCPSERVER */

#ifdef LWIP_DEBUG_UDPSERVER
void
udpserver(int argc, char **argv)
{
  int sockfd, fromlen;
  int ret, i_port_val;
  struct sockaddr_in seraddr;
  struct sockaddr_in cliaddr;
  size_t n, i;

  char msg[MAX_SIZE];
  uint16_t port;
  if (argv == NULL) {
    return;
  }
  if (argc < 1) {
    PRINTK("\nUsage: udpserver <port>\n");
    return;
  }

  i_port_val = atoi(argv[0]);
  /* Port 0 not supported , negative values not supported , max port limit is 65535 */
  if ((i_port_val <= 0) || (i_port_val > 65535)) {
    PRINTK("\nUsage: Invalid Port\n");
    return;
  }

  port = (uint16_t)i_port_val;

  PRINTK("port:%d\r\n", port);

  sockfd = lwip_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  (void)memset_s(&seraddr, sizeof(seraddr), 0, sizeof(seraddr));
  (void)memset_s(&cliaddr, sizeof(cliaddr), 0, sizeof(cliaddr));
  seraddr.sin_family = AF_INET;
  seraddr.sin_addr.s_addr = htonl(INADDR_ANY);
  seraddr.sin_port = htons(port);
  ret = lwip_bind(sockfd, (struct sockaddr *)&seraddr, sizeof(seraddr));
  if (ret < 0) {
    PRINTK("bind ip and port failed:%d\n", errno);
    (void)closesocket(sockfd);
    return;
  }

  while (1) {
    ret = recvfrom(sockfd, msg, MAX_SIZE - 1, 0, (struct sockaddr *)&cliaddr, (socklen_t *)&fromlen);
    if (ret < 0) {
      if ((errno == EAGAIN) || (errno == EINTR)) {
        continue;
      } else {
        break;
      }
    }
    n = strlen(msg);
    for (i = 0; i < n; ++i) {
      if (msg[i] >= 'a' && msg[i] <= 'z') {
        msg[i] = (char)(msg[i] + 'A' - 'a');
      } else if (msg[i] >= 'A' && msg[i] <= 'Z') {
        msg[i] = (char)(msg[i] + 'a' - 'A');
      }
    }
    ret = sendto(sockfd, msg, n + 1, 0, (struct sockaddr *)&cliaddr, (socklen_t)fromlen);
    if ((ret <= 0) && (errno == EPIPE)) {
      break;
    }
  }

  (void)closesocket(sockfd);
  return;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(udpserver_shellcmd, CMD_TYPE_EX, "udpserver",  XARGS, (CmdCallBackFunc)udpserver);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_DEBUG_UDPSERVER */

#ifdef LWIP_DEBUG_INFO
LWIP_STATIC
u32_t
netdebug_memp(int argc, char **argv)
{
  u32_t ret = LOS_OK;
  int type;

  if (argc == 2) {
    if (!strcmp("-i", argv[1])) {
      debug_memp_info();
    } else if (!strcmp("-udp", argv[1])) {
      debug_memp_type_info(MEMP_UDP_PCB);
    } else if (!strcmp("-tcp", argv[1])) {
      debug_memp_type_info(MEMP_TCP_PCB);
    } else if (!strcmp("-raw", argv[1])) {
      debug_memp_type_info(MEMP_RAW_PCB);
    } else if (!strcmp("-conn", argv[1])) {
      debug_memp_type_info(MEMP_NETCONN);
    } else {
      ret = LOS_NOK;
    }
  } else if (argc == 3) {
    if (!strcmp("-d", argv[1])) {
      type = atoi(argv[2]);
      if (type >= 0) {
        debug_memp_detail(type);
      } else {
        PRINTK("Error: type < 0\n");
        ret = LOS_NOK;
      }
    } else {
      ret = LOS_NOK;
    }
  } else {
    ret = LOS_NOK;
  }

  return ret;
}

LWIP_STATIC
u32_t
netdebug_sock(int argc, char **argv)
{
  int idx;
  u32_t ret = LOS_NOK;

  if (argc == 2) {
    if (strcmp("-i", argv[1]) == 0) {
      /* netdebug sock -i */
      for (idx = 0; idx < (int)LWIP_CONFIG_NUM_SOCKETS; idx++) {
        debug_socket_info(idx, 1, 0);
      }
      ret = LOS_OK;
    }
  } else if (argc == 3) {
    if (strcmp("-d", argv[1]) == 0) {
      /* netdebug sock -d <idx> */
      idx = atoi(argv[2]);
      if (idx >= 0) {
        debug_socket_info(idx, 1, 1);
        ret = LOS_OK;
      } else {
        PRINTK("Error: idx < 0\n");
      }
    }
  }

  return ret;
}

u32_t
osShellNetDebug(int argc, char **argv)
{
  u32_t ret = LOS_NOK;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (argc < 1) {
    goto usage;
  }
  if (strcmp("memp", argv[0]) == 0) {
    LOCK_TCPIP_CORE();
    ret = netdebug_memp(argc, argv);
    UNLOCK_TCPIP_CORE();
    if (ret != LOS_OK) {
      goto usage_memp;
    }
  } else if (strcmp("sock", argv[0]) == 0) {
    /* netdebug sock {-i | -d <idx>} */
    LOCK_TCPIP_CORE();
    ret = netdebug_sock(argc, argv);
    UNLOCK_TCPIP_CORE();
    if (ret != LOS_OK) {
      goto usage_sock;
    }
  } else {
    goto usage;
  }
  return ret;

usage:
  /* Cmd help */
  PRINTK("\nUsage:\n");
  PRINTK("netdebug memp {-i | -d <type> | -udp | -tcp | -raw |-conn}\n");
  PRINTK("netdebug sock {-i | -d <idx>}\n");
  return LOS_NOK;

usage_memp:
  /* netdebug memp help */
  PRINTK("\nUsage:\n");
  PRINTK("netdebug memp {-i | -d <type> | -udp | -tcp | -raw |-conn}\n");
  return LOS_NOK;

usage_sock:
  /* netdebug sock help */
  PRINTK("\nUsage:\n");
  PRINTK("netdebug sock {-i | -d <idx>}\n");
  return LOS_NOK;
}
#endif /* LWIP_DEBUG_INFO */

#if defined(LOSCFG_SHELL) && defined(LWIP_DEBUG_INFO)
SHELLCMD_ENTRY(netdebug_shellcmd, CMD_TYPE_EX, "netdebug",  XARGS, (CmdCallBackFunc)osShellNetDebug);
#endif /* LOSCFG_SHELL && LWIP_DEBUG_INFO */

static void
display_ipv6_prefix(void)
{
  u8_t i;
  char ac_ipv6_addr[IP6ADDR_STRLEN_MAX + 1] = {0};
  u8_t atleast_one_entry = 0;
  /* Display prefix */
  PRINTK("=================\n");
  PRINTK("|| Prefix List ||\n");
  PRINTK("=================\n");
  PRINTK("%-50s %-16s %-20s\n",
         "Prefix", "netif", "validLifetime");
  PRINTK("---------------------------------------------------------------------------------\n");
  /* Display neighbour Cache Entry */
  for (i = 0; i < LWIP_ND6_NUM_PREFIXES; i++) {
    if (prefix_list[i].netif != NULL && prefix_list[i].invalidation_timer > 0) {
      atleast_one_entry = 1;
      (void)ip6addr_ntoa_r((const ip6_addr_t *)(prefix_list[i].prefix.addr), (ac_ipv6_addr), INET6_ADDRSTRLEN);
      PRINTK("%-50s ", ac_ipv6_addr);
      PRINTK("%s%-13u ", prefix_list[i].netif->name, prefix_list[i].netif->num);
      PRINTK("%-20u\n", prefix_list[i].invalidation_timer);
    }
  }
  if (atleast_one_entry == 0) {
    PRINTK("**** NO VALID PREFIXES FOUND CONFIGURED ****\n");
  }
  PRINTK("---------------------------------------------------------------------------------\n");
}

static void
display_ipv6_neighbor_cache_entry(void)
{
  u8_t i;
  u8_t atleast_one_entry = 0;
  char ac_ipv6_addr[IP6ADDR_STRLEN_MAX + 1] = {0};
  char aclladdr[20] = {0};
  const char *ac_states[] = {"NO_ENTRY", "INCOMPLETE", "REACHABLE", "STALE", "DELAY", "PROBE"};

  PRINTK("\n\n");
  PRINTK("============================\n");
  PRINTK("|| Neighbor Cache Entries ||\n");
  PRINTK("============================\n");
  PRINTK("%-50s %-25s %-16s %-15s %-10s\n",
         "Neighbor", "MAC", "netif", "state", "IsRouter");
  PRINTK("------------------------------------------------------------"
         "----------------------------------------------------------\n");

  /* Display neighbour Cache Entry */
  for (i = 0; i < LWIP_ND6_NUM_NEIGHBORS; i++) {
    if (neighbor_cache[i].state != ND6_NO_ENTRY) {
      atleast_one_entry = 1;
      (void)ip6addr_ntoa_r((const ip6_addr_t *)(neighbor_cache[i].next_hop_address.addr), (ac_ipv6_addr),
                           INET6_ADDRSTRLEN);
      PRINTK("%-50s ", ac_ipv6_addr);

      if (snprintf_s(aclladdr, sizeof(aclladdr), sizeof(aclladdr) - 1, "%02X:%02X:%02X:%02X:%02X:%02X",
                     neighbor_cache[i].lladdr[0], neighbor_cache[i].lladdr[1], neighbor_cache[i].lladdr[2],
                     neighbor_cache[i].lladdr[3], neighbor_cache[i].lladdr[4], neighbor_cache[i].lladdr[5]) < 0) {
        return LOS_NOK;
      }
      PRINTK("%-25s ", aclladdr);
      PRINTK("%s%-13u ", neighbor_cache[i].netif->name, neighbor_cache[i].netif->num);
      PRINTK("%-15s ", ac_states[neighbor_cache[i].state]);
      PRINTK("%-10s\n", neighbor_cache[i].isrouter ? "Yes" : "No");
    }
  }
  if (atleast_one_entry == 0) {
    PRINTK("**** NO NEIGHBOURS FOUND ****\n");
  }
  PRINTK("------------------------------------------------------------"
         "----------------------------------------------------------\n");
}

static void
display_ipv6_des_cache_entry(void)
{
  u8_t i;
  u8_t atleast_one_entry = 0;
  char ac_ipv6_addr[IP6ADDR_STRLEN_MAX + 1] = {0};
  PRINTK("\n\n");
  PRINTK("===============================\n");
  PRINTK("|| Destination Cache Entries ||\n");
  PRINTK("===============================\n");
  PRINTK("%-50s %-50s %-10s %-10s\n",
         "Destination", "NextHop", "PMTU", "age");
  PRINTK("------------------------------------------------------------"
         "--------------------------------------------------------\n");
  /* Display neighbour Cache Entry */
  for (i = 0; i < LWIP_ND6_NUM_DESTINATIONS; i++) {
    if (!ip6_addr_isany(&(destination_cache[i].destination_addr))) {
      atleast_one_entry = 1;
      (void)ip6addr_ntoa_r((const ip6_addr_t *)(destination_cache[i].destination_addr.addr), (ac_ipv6_addr),
                           INET6_ADDRSTRLEN);
      PRINTK("%-50s ", ac_ipv6_addr);
      (void)ip6addr_ntoa_r((const ip6_addr_t *)(destination_cache[i].next_hop_addr.addr), (ac_ipv6_addr),
                           INET6_ADDRSTRLEN);
      PRINTK("%-50s ", ac_ipv6_addr);
      PRINTK("%-10u ", destination_cache[i].pmtu);
      PRINTK("%-10u\n", destination_cache[i].age);
    }
  }
  if (atleast_one_entry == 0) {
    PRINTK("**** NO DESTINATION CACHE FOUND ****\n");
  }
  PRINTK("------------------------------------------------------------"
         "--------------------------------------------------------\n");
}

static void
display_default_router_entry(void)
{
  u8_t i;
  u8_t atleast_one_entry = 0;
  char ac_ipv6_addr[IP6ADDR_STRLEN_MAX + 1] = {0};
  PRINTK("\n\n");
  PRINTK("============================\n");
  PRINTK("|| Default Router Entries ||\n");
  PRINTK("============================\n");
  PRINTK("%-50s %-20s %-10s\n",
         "Router", "invalidation_timer", "flags");
  PRINTK("-----------------------------------------------------------------------------\n");
  /* Display Default Router Cache Entry */
  for (i = 0; i < LWIP_ND6_NUM_ROUTERS; i++) {
    if (default_router_list[i].neighbor_entry) {
      atleast_one_entry = 1;
      (void)ip6addr_ntoa_r((const ip6_addr_t *)((default_router_list[i].neighbor_entry)->next_hop_address.addr),
                           (ac_ipv6_addr), INET6_ADDRSTRLEN);
      PRINTK("%-50s ", ac_ipv6_addr);
      PRINTK("%-20u ", default_router_list[i].invalidation_timer);
      PRINTK("%-10u\n", default_router_list[i].flags);
    }
  }
  if (atleast_one_entry == 0) {
    PRINTK("**** NO DEFAULT ROUTERS FOUND ****\n");
  }
  PRINTK("-----------------------------------------------------------------------------\n");
}

u32_t
osShellIpDebug(int argc, char **argv)
{
  LWIP_UNUSED_ARG(argc);
  LWIP_UNUSED_ARG(argv);

  if (tcpip_init_finish == 0) {
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
    goto exit;
  }

  display_ipv6_prefix();
  display_ipv6_neighbor_cache_entry();
  display_ipv6_des_cache_entry();
  display_default_router_entry();

exit:
  return LOS_OK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ipdebug_shellcmd, CMD_TYPE_EX, "ipdebug", XARGS, (CmdCallBackFunc)osShellIpDebug);
#endif /* LOSCFG_SHELL */

u32_t
os_shell_netif(int argc, char **argv)
{
  struct netif *netif = NULL;
  if (argv == NULL) {
    return LOS_NOK;
  }
  if (argc < 1) {
    PRINTK("netif_default wlan0\n");
    return LOS_NOK;
  }

  netif = netif_find(argv[0]);
  if (netif == NULL) {
    PRINTK("not find %s\n", argv[0]);
    return LOS_NOK;
  }

  (void)netifapi_netif_set_default(netif);
  return LOS_OK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(netif_shellcmd, CMD_TYPE_EX, "netif_default", XARGS, (CmdCallBackFunc)os_shell_netif);
#endif /* LOSCFG_SHELL */

#ifdef LWIP_TESTBED
extern void cmd_reset(void);
u32_t
osShellReboot(int argc, const char **argv)
{
  cmd_reset();
  return LOS_OK;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(reboot_shellcmd, CMD_TYPE_EX, "reboot", XARGS, (CmdCallBackFunc)osShellReboot);
#endif /* LOSCFG_SHELL */
#endif

#endif /* LWIP_ENABLE_LOS_SHELL_CMD */
#if LWIP_IPV4 && LWIP_IGMP
static void
osShellIgmpUsage(void)
{
  PRINTK("igmp\n\tshow\n\tifname {start | stop | report}\n\t{ifname | ifaddr} {join | leave} groupaddr\n");
}

static void
igmp_netif_show(void)
{
  struct netif *netif_p = NULL;
  struct igmp_group *igmp_group_p = NULL;
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("\t%-16s%-16s%-16s%-16s%-16s\n", "groupaddr", "reporter", "state", "timer(100ms)", "use");
#else
  PRINTK("\t%-16s%-16s%-16s%-16s%-16s\n", "groupaddr", "reporter", "state", "timer(100ms)", "use");
#endif
  for (netif_p = netif_list; netif_p != NULL; netif_p = netif_p->next) {
    if ((netif_p->flags & NETIF_FLAG_IGMP) == 0) {
      continue;
    }
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s%d\n", netif_p->name, netif_p->num);
#else
    PRINTK("%s%d\n", netif_p->name, netif_p->num);
#endif
    igmp_group_p = netif_igmp_data(netif_p);
    if (igmp_group_p == NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("\n");
#else
      PRINTK("\n");
#endif
      continue;
    }
    while (igmp_group_p != NULL) {
#ifdef LWIP_DEBUG_OPEN
      (void)hi_at_printf("\t%-16s%-16d%-16d%-16d%-16d\n", ip4addr_ntoa(&(igmp_group_p->group_address)),
                         igmp_group_p->last_reporter_flag, igmp_group_p->group_state,
                         igmp_group_p->timer, igmp_group_p->use);
#else
      PRINTK("\t%-16s%-16d%-16d%-16d%-16d\n", ip4addr_ntoa(&(igmp_group_p->group_address)),
             igmp_group_p->last_reporter_flag, igmp_group_p->group_state,
             igmp_group_p->timer, igmp_group_p->use);
#endif
      igmp_group_p = igmp_group_p->next;
    }
  }
}

static s32_t
igmp_netif_control(char **argv)
{
  s32_t ret = 0;
  struct netif *netif_p = NULL;

  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("no such netif named %s\n", argv[0]);
#else
    PRINTK("no such netif named %s\n", argv[0]);
#endif
    goto usage;
  }
  if (strcmp(argv[1], "start") == 0) {
    ret = igmp_start(netif_p);
  } else if (strcmp(argv[1], "stop") == 0) {
    ret = igmp_stop(netif_p);
  } else if (strcmp(argv[1], "report") == 0) {
    igmp_report_groups(netif_p);
  } else {
    goto usage;
  }

  return ret;
usage:
  osShellIgmpUsage();
  return -1;
}

static s32_t
igmp_membership_netif_ctrl(struct netif *netif_p,
                           ip4_addr_t groupaddr, char **argv)
{
  s32_t ret;

  if (strcmp(argv[1], "join") == 0) {
    ret = igmp_joingroup_netif(netif_p, &groupaddr);
  } else if (strcmp(argv[1], "leave") == 0) {
    ret = igmp_leavegroup_netif(netif_p, &groupaddr);
  } else {
    ret = -1;
    osShellIgmpUsage();
  }

  return ret;
}

static s32_t
igmp_membership_addr_ctrl(ip4_addr_t groupaddr,
                          char **argv)
{
  s32_t ret = 0;
  ip4_addr_t ifaddr = {0};

  ifaddr.addr = inet_addr(argv[0]);
  if (ifaddr.addr == IPADDR_NONE) {
    goto usage;
  }
  if (strcmp(argv[1], "join") == 0) {
    ret = igmp_joingroup(&ifaddr, &groupaddr);
  } else if (strcmp(argv[1], "leave") == 0) {
    ret = igmp_leavegroup(&ifaddr, &groupaddr);
  } else {
    goto usage;
  }

  return ret;
usage:
  osShellIgmpUsage();
  return -1;
}

static s32_t
igmp_membership_ctrl(char **argv)
{
  s32_t ret;
  struct netif *netif_p = NULL;
  ip4_addr_t groupaddr = {0};

  groupaddr.addr = inet_addr(argv[2]);
  if ((groupaddr.addr == IPADDR_NONE) || !(ip4_addr_ismulticast(&groupaddr))) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("invalid groupaddr %s\n", argv[2]); // 2 is cast addr
#else
    PRINTK("invalid groupaddr %s\n", argv[2]); // 2 is cast addr
#endif
    osShellIgmpUsage();
    return -1;
  }
  netif_p = netif_find(argv[0]);
  if (netif_p == NULL) {
    ret = igmp_membership_addr_ctrl(groupaddr, argv);
  } else {
    ret = igmp_membership_netif_ctrl(netif_p, groupaddr, argv);
  }

  return ret;
}

u32_t
osShellIgmp(int argc, char **argv)
{
  s32_t ret = 0;

  if (tcpip_init_finish == 0) {
#ifdef LWIP_DEBUG_OPEN
    (void)hi_at_printf("%s: tcpip_init have not been called\n", __FUNCTION__);
#else
    PRINTK("%s: tcpip_init have not been called\n", __FUNCTION__);
#endif
    return LOS_NOK;
  }
  if (argv == NULL) {
    return LOS_NOK;
  }
  if ((argc == 1) && (strcmp(argv[0], "show") == 0)) {
    igmp_netif_show();
  } else if (argc == 2) {
    ret = igmp_netif_control(argv);
  } else if (argc == 3) {
    ret = igmp_membership_ctrl(argv);
  } else {
    osShellIgmpUsage();
  }
#ifdef LWIP_DEBUG_OPEN
  (void)hi_at_printf("igmp ret %d\n", ret);
#else
  PRINTK("igmp ret %d\n", ret);
#endif
  return LOS_OK;
}

u32_t
at_osShellIgmp(int argc, char **argv)
{
  u32_t ret = osShellIgmp(argc, argv);

  return ret;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(igmp_shellcmd, CMD_TYPE_EX, "igmp", XARGS, (CmdCallBackFunc)osShellIgmp);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_IPV4 && LWIP_IGMP */
